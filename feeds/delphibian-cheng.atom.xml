<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Log4D</title><link href="/" rel="alternate"></link><link href="/feeds/delphibian-cheng.atom.xml" rel="self"></link><id>/</id><updated>2011-03-29T00:00:00+08:00</updated><entry><title>历史记录-歌词复制器</title><link href="/2011/03/plrcmatch4d/" rel="alternate"></link><updated>2011-03-29T00:00:00+08:00</updated><author><name>alswl</name></author><id>tag:,2011-03-29:2011/03/plrcmatch4d/</id><summary type="html">&lt;p&gt;之前写过一个Java的小工具叫做Mp3Lrc歌词复制器，用来复制歌词到Mp3播放器中的对应目录下面。之前的文章参见&lt;a href="http:/
/log4d.com/2009/05/the-executable-file-
mp3lrc"&gt;Mp3Lrc的可执行文件&lt;/a&gt;和&lt;a href="http://log4d.com/2009/05/lyrics-written-in-java-
replicator-mp3"&gt;Java写的Mp3歌词复制器&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这几天整理硬盘时候发现大四时候还用Delphi写了一个完整的GUI界面的Mp3歌词复制工具叫做PLrcMatch4D。&lt;/p&gt;
&lt;p&gt;源码已经丢失，只剩下可执行文件，T_T。&lt;/p&gt;
&lt;p&gt;如果非要定义以下这个工具的作用，就是从某个固定文件夹（歌词文件夹）复制对应Mp3播放器中歌曲的lrc文件到目标文件夹，从而让Mp3播放器可以正常显示歌词。&lt;/p&gt;
&lt;p&gt;下载点击这里，&lt;a href="http://upload-
log4d.qiniudn.com/2011/03/PLrcMatch4D.zip"&gt;PLrcMatch4D.zip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;界面比较实在，大致是这样：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://upload-log4d.qiniudn.com/2011/03/plrcmatch4d.jpg" /&gt;&lt;/p&gt;</summary><category term=""></category></entry><entry><title>Delphi 的单元测试工具DUnit</title><link href="/2010/01/delphi-unit-testing-tool-dunit/" rel="alternate"></link><updated>2010-01-06T00:00:00+08:00</updated><author><name>alswl</name></author><id>tag:,2010-01-06:2010/01/delphi-unit-testing-tool-dunit/</id><summary type="html">&lt;p&gt;以前写Java时候经常使用一款单元测试工具JUnit，工作之后在用Delphi，自然也要换到Delphi下面的单元测试工具DUnit。&lt;/p&gt;
&lt;p&gt;DUnit是XUnit家族中的一员，是Extreme Programming测试实现Xtreme Testing的一种工具。&lt;/p&gt;
&lt;p&gt;DUnit的用法和JUnit很类似，如果有相关经验很容易上手。这里是DUnit的官方地址：&lt;a href="h
ttp://dunit.sourceforge.net/"&gt;http://dunit.sourceforge.net/&lt;/a&gt; ，下载地址：&lt;a href="h
ttp://sourceforge.net/projects/dunit/"&gt;http://sourceforge.net/projects/dunit/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将DUnit解压至任意目录（我习惯在&lt;code&gt;D:/Study/DelphiLib/&lt;/code&gt;），打开Delphi 7，将DUnit路径添加到 Tools- &amp;gt;
Environment Options 里面的 Library -&amp;gt; Library Path，这样DUnit就安装完成了。&lt;/p&gt;
&lt;p&gt;如果有装过CnPack 的Delphi工具包，就可以很轻松的在 File -&amp;gt; New -&amp;gt; Other -&amp;gt; CnPack -&amp;gt;
DUnit测试实例生成向导 中建立新的测试用例。&lt;/p&gt;
&lt;p&gt;下面是我的一个简单的测试用例，测试AppFun中的&lt;code&gt;GetString()&lt;/code&gt;和 &lt;code&gt;Add()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;TAppFun.pas&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;(*&lt;/span&gt;
&lt;span class="c"&gt;  UTest by Jason&lt;/span&gt;
&lt;span class="c"&gt;  2010-01-06 21:30&lt;/span&gt;
&lt;span class="c"&gt;*)&lt;/span&gt;
&lt;span class="kt"&gt;unit&lt;/span&gt; &lt;span class="nc"&gt;AppFun&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;interface&lt;/p&gt;
&lt;p&gt;uses SysUtils;&lt;/p&gt;
&lt;p&gt;type TAppFun = class(TObject)&lt;/p&gt;
&lt;p&gt;public&lt;/p&gt;
&lt;p&gt;class function GetString(sName: string; iAge: Integer): string;&lt;/p&gt;
&lt;p&gt;class function Add(iA: Integer; iB: Integer): Integer;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;implementation&lt;/p&gt;
&lt;p&gt;class function TAppFun.GetString(sName: string; iAge: Integer): string;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;result := 'Hello ' + sName + ', your age is ' +&lt;/p&gt;
&lt;p&gt;IntToStr(iAge);&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;class function TAppFun.Add(iA: Integer; iB: Integer): Integer;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;Result := iA + iB;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;end.&lt;/p&gt;
&lt;p&gt;UTest.pas&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;(*&lt;/span&gt;
&lt;span class="c"&gt;  UTest by Jason&lt;/span&gt;
&lt;span class="c"&gt;  2010-01-06 21:30&lt;/span&gt;
&lt;span class="c"&gt;*)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;unit UTest;&lt;/p&gt;
&lt;p&gt;interface&lt;/p&gt;
&lt;p&gt;uses&lt;/p&gt;
&lt;p&gt;Windows, SysUtils, Classes, TestFramework, TestExtensions;&lt;/p&gt;
&lt;p&gt;type&lt;/p&gt;
&lt;p&gt;TTest = class(TTestCase)&lt;/p&gt;
&lt;p&gt;protected&lt;/p&gt;
&lt;p&gt;procedure SetUp; override;&lt;/p&gt;
&lt;p&gt;procedure TearDown; override;&lt;/p&gt;
&lt;p&gt;published&lt;/p&gt;
&lt;p&gt;procedure Test;&lt;/p&gt;
&lt;p&gt;procedure TestGetString();&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;implementation&lt;/p&gt;
&lt;p&gt;uses&lt;/p&gt;
&lt;p&gt;AppFun, Dialogs;&lt;/p&gt;
&lt;p&gt;procedure TTest.Setup;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;ShowMessage('In Setup!');&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;procedure TTest.TearDown;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;ShowMessage('In TearDown!');&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;procedure TTest.Test;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;Self.Check(TAppFun.GetString('Jason', 22) = 'Hello Jason, your age is 22',&lt;/p&gt;
&lt;p&gt;'Second Test');&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;procedure TTest.TestGetString();&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;Check(TAppFun.Add(3, 5) = 8, 'First Test');&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;initialization&lt;/p&gt;
&lt;p&gt;TestFramework.RegisterTest(TTest.Suite);&lt;/p&gt;
&lt;p&gt;end.&lt;/p&gt;
&lt;p&gt;从上面的代码可以看出，XUnit系列风格都比较类似，很容易操作。&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&lt;a href="http://upload-
log4d.qiniudn.com/2010/01/dunit.jpg"&gt;&lt;img alt="" src="http://upload-" title="log4d.qiniudn.com/2010/01/dunit.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;DUnit还有一些更高阶的操作，比如在控制台输出/在独立线程中运行测试/Exception测试等等，详细操作可以参考下列文档。目前我用到的就是简单的单元测试
。&lt;/p&gt;
&lt;p&gt;一点资料：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dunit.sourceforge.net/"&gt;DUnit 的官方地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://sourceforge.net/projects/dunit/"&gt;DUnit 下载地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://dunit.sourceforge.net/README.html"&gt;DUnit 官方文档（英文）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://dunit.sourceforge.net/README_CHT.html"&gt;DUnit 官方文档（繁体中文）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.delphifans.com/infoview/Article_499.html"&gt;『Delphi园地』-Delphi单元测试工具Dunit介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.51testing.com/html/32/297.html"&gt;Delphi单元测试工具Dunit介绍_51Testing软件测试网&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Delphi宝刀不老啊～呵呵～&lt;/p&gt;</summary><category term="Delphi"></category><category term="Lib"></category><category term="Testing"></category></entry><entry><title>Delphi学习笔记06</title><link href="/2009/12/delphi-study-notes-06/" rel="alternate"></link><updated>2009-12-05T00:00:00+08:00</updated><author><name>alswl</name></author><id>tag:,2009-12-05:2009/12/delphi-study-notes-06/</id><summary type="html">&lt;p&gt;我的博客所在的江西服务器需要服务器搬迁，所以这两天博客无法访问，看到404错误的童鞋们对不起拉…&lt;/p&gt;
&lt;h2&gt;几个概念：Owner/Parent/Sender/Self&lt;/h2&gt;
&lt;p&gt;Owner/Parent的字面意义都有点拥有者的意思，一个Button的Owner和Parent很有可能都是Form，但实际上这两个概念是没有关系的。&lt;/p&gt;
&lt;p&gt;Owner和Parent的区别：Parent对应组件的视觉容器而不是拥有者，比如一个&lt;code&gt;RadioGroup&lt;/code&gt;是&lt;code&gt;RadioButton&lt;/code&gt;的Parent；Ow
ner对应组件的拥有者。尽管Parent和Owner很多时候都是同一个对象，但是还是需要严格区分的。&lt;/p&gt;
&lt;p&gt;Sender代表的是触发事件的组件，有了Sender参数，能够使用多个组件配合使用。在代码中可以使用&lt;code&gt;(Sender as
TButton).Caption&lt;/code&gt;这种语句来转换&lt;code&gt;TObject&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;Self呢，相当于C++/Java中的&lt;code&gt;this&lt;/code&gt;，指向当前对象，代表自身的意思。没有太多可讲的，我觉得如果要获取某个属性，前面加上Self.是个好习惯。&lt;/p&gt;
&lt;p&gt;这几个关键字能够加深对面向对象的理解，在VCL编程中，也是必须掌握的。&lt;/p&gt;
&lt;h2&gt;VCL编程感观&lt;/h2&gt;
&lt;p&gt;VCL全程Visual Component Library（可视组件库），称为VCL编程不知道合适不合适，VCL是一个框架，包含相当丰富的控件，多到让我咂舌
，长长的控件面板还要拖拉好几次才能看到全部。Delphi之所以强大，就是因为这个VCL。&lt;/p&gt;
&lt;p&gt;比如文件操作，有很多基于传统Pascal的方法，&lt;code&gt;FileExists()/DirectoryExists()/RenamFile()&lt;/code&gt;这种原始的方法，完全
不是基于面向对象思想的。就我这几天的感觉，应该使用&lt;code&gt;TFileStream&lt;/code&gt;这样的类，官方描述是"Use TFileStream to access the
information in disk files. TFileStream will open a named file and provide
methods to read from or write to it. "，"用来读取硬盘上文件的信息，打开一个文件并确定一种操作文件读写的权限"，用这个
类来操作文件就类似于Java那种方法，而不是C那样的大量繁琐的函数。这个类的被设计用来读取文件，而不擅长操作文件和文件夹。在这一点上我还是比较喜欢Java中
&lt;code&gt;File&lt;/code&gt;的操作方法。&lt;/p&gt;
&lt;p&gt;我一直把Delphi和C#进行对比，这两者都是出自于同一人。Delphi和C#很多编程思想和结构都非常类似。C#中窗体有&lt;code&gt;.cs&lt;/code&gt;和&lt;code&gt;.desiner.cs&lt;/code&gt;，Delphi中有&lt;code&gt;.dfm&lt;/code&gt;和&lt;code&gt;.pas&lt;/code&gt;。我对Delphi的一点点不喜欢是觉得他继承了太多的Pascal的东西，导致有时候不容易对设计进行思维转换。D
elphi最强大的在于VCL，可惜现在Borland都被收购，Delphi成为一门强大而不够活力的语言。&lt;/p&gt;
&lt;h2&gt;CnPack包&lt;/h2&gt;
&lt;p&gt;我之前使用的&lt;a href="http://www.xdowns.com/soft/38/121/2008/Soft_42203.html"&gt;DELPHI 7 绿色终结版&lt;/a&gt;
被我换成了原装的之后，发现之前很多功能消失了。检查后发现，原来DELPHI 7 绿色终结版集成了CnPack这一套组件包。&lt;/p&gt;
&lt;p&gt;CnPack 是由互联网上一群中国程序员开发的开放源码的自由软件项目，该项目组成立于2002年。当前该项目组的主要的工作成果包括 CnPack
组件包、CnWizards 专家包以及 CVSTracNT 错误跟踪系统等。CnPack 开发团队目前规模有 200 余人，并且还在不断发展壮大中。&lt;/p&gt;
&lt;p&gt;下载CnPack，&lt;a href="http://www.cnpack.org/"&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Delphi的异常处理&lt;/h2&gt;
&lt;p&gt;这篇文章是这几天本地保存的内容合成的，所以有点乱。下面是我学Delphi基础的最后一块内容，异常处理，代码如下。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;program&lt;/span&gt; &lt;span class="n"&gt;P1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;try&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;catch&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;try&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;finally&lt;/span&gt;&lt;span class="err"&gt;的使用&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{$APPTYPE CONSOLE}&lt;/p&gt;
&lt;p&gt;uses&lt;/p&gt;
&lt;p&gt;SysUtils;&lt;/p&gt;
&lt;p&gt;{创建异常MyErr,并使用Raise抛出}&lt;/p&gt;
&lt;p&gt;procedure RaiseTest();&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;MyErr : Exception;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;MyErr := Exception.Create('My Error');&lt;/p&gt;
&lt;p&gt;Writeln(MyErr.Message);&lt;/p&gt;
&lt;p&gt;Raise MyErr;&lt;/p&gt;
&lt;p&gt;MyErr.Free;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;{使用try...except来捕获错误，使用on...do&lt;/p&gt;
&lt;p&gt;来判断错误类型&lt;/p&gt;
&lt;p&gt;加入try...finally(这个语法结构真失败，无法&lt;/p&gt;
&lt;p&gt;嵌套try...except...finally)}&lt;/p&gt;
&lt;p&gt;procedure TryExceptTest();&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;i, j, k : Integer;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;Readln(i, j);&lt;/p&gt;
&lt;p&gt;try&lt;/p&gt;
&lt;p&gt;try&lt;/p&gt;
&lt;p&gt;k := i div j;&lt;/p&gt;
&lt;p&gt;Writeln(k);&lt;/p&gt;
&lt;p&gt;except&lt;/p&gt;
&lt;p&gt;on E : EInOutError do&lt;/p&gt;
&lt;p&gt;Writeln('Input Error! Message: ', E.Message);&lt;/p&gt;
&lt;p&gt;on E : EdivByZero do&lt;/p&gt;
&lt;p&gt;Writeln('/ Error! Message: ', E.Message);&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;finally&lt;/p&gt;
&lt;p&gt;Writeln('in finally.');&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;//RaiseTest();&lt;/p&gt;
&lt;p&gt;TryExceptTest();&lt;/p&gt;
&lt;p&gt;Readln;&lt;/p&gt;
&lt;p&gt;end.&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;前天在把&lt;a href="http://log4d.com/2009/05/the-executable-file-
mp3lrc"&gt;Mp3Lrc&lt;/a&gt;这个小工具写成Delphi的GUI版本，由于昨天课程设计提前答辩，所以没能完成，争取今天晚上弄好。&lt;/p&gt;</summary><category term=""></category></entry><entry><title>Dlphi资料小汇总</title><link href="/2009/12/dlphi-a-small-summary-of-knowledge/" rel="alternate"></link><updated>2009-12-05T00:00:00+08:00</updated><author><name>alswl</name></author><id>tag:,2009-12-05:2009/12/dlphi-a-small-summary-of-knowledge/</id><summary type="html">&lt;p&gt;学Delphi大概一周时间，我经历从当初的初生牛犊不怕虎，到现在感慨Delphi的强大和复杂。说实话，我以前觉得Delphi是一门过气的语言，现在我重新修正
自己的观点，没有弱势的语言，只有菜鸟的程序员。&lt;/p&gt;
&lt;p&gt;Delphi的整个架构让我叹为观止，我这么短的学习周期，只能学到一点基础的皮毛。由于完全自学，我花费很多精力在资料的收集上（很痛苦没有找到一本合适的书），现
在我把我这段时间的资料收集整理，分享我的所得（这篇文章经历1个星期，发布时候遇到服务器卡住，丢失了一次，幸好我灵机一动，用FireFox脱机找回了缓存页面，
还是得信春哥啊）。&lt;/p&gt;
&lt;p&gt;资料繁杂，很多都是来自信息采集站点，我无法一一署名，在这里对这些资料的原作者表示谢意。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Delphi7的文件类型&lt;/li&gt;
&lt;li&gt;Delphi的关键字&lt;/li&gt;
&lt;li&gt;类型之间转换函数&lt;/li&gt;
&lt;li&gt;组件的常用属性&lt;/li&gt;
&lt;li&gt;组件的常用事件&lt;/li&gt;
&lt;li&gt;常用类型和函数的uses单元&lt;/li&gt;
&lt;li&gt;Delphi常用的ADO组件&lt;/li&gt;
&lt;li&gt;ADO组件常用属性&lt;/li&gt;
&lt;li&gt;ADO数据集类组件的共同方法&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Delphi7的文件类型&lt;/h2&gt;
&lt;p&gt;文件扩展名 文件类型说明 产生时间&lt;/p&gt;
&lt;p&gt;BMP、ICO、CUR&lt;/p&gt;
&lt;p&gt;位图、图标及光标图像文件&lt;/p&gt;
&lt;p&gt;程序设计时&lt;/p&gt;
&lt;p&gt;BGP&lt;/p&gt;
&lt;p&gt;项目组文件，由多目标项目管理器产生&lt;/p&gt;
&lt;p&gt;程序设计时&lt;/p&gt;
&lt;p&gt;BPL&lt;/p&gt;
&lt;p&gt;BORLAND PACKAGE LIBRARY（组件库文件）&lt;/p&gt;
&lt;p&gt;编译连接后&lt;/p&gt;
&lt;p&gt;CBA&lt;/p&gt;
&lt;p&gt;压缩格式文件，做WEB发布时使用&lt;/p&gt;
&lt;p&gt;设计时&lt;/p&gt;
&lt;p&gt;CFG&lt;/p&gt;
&lt;p&gt;项目配置文件。项目配置文件保存着项目的配置信息&lt;/p&gt;
&lt;p&gt;设计时&lt;/p&gt;
&lt;p&gt;DCP&lt;/p&gt;
&lt;p&gt;DELPHI COMPONENT PACKAGE（Delphi组件包）&lt;/p&gt;
&lt;p&gt;编译时&lt;/p&gt;
&lt;p&gt;DCU&lt;/p&gt;
&lt;p&gt;DELPHI COMPILED UNIT，编译原始文件后的中间产物&lt;/p&gt;
&lt;p&gt;编译时&lt;/p&gt;
&lt;p&gt;DFM&lt;/p&gt;
&lt;p&gt;DELPHI FORM FILE（窗体文件）&lt;/p&gt;
&lt;p&gt;程序设计时&lt;/p&gt;
&lt;p&gt;~DFM&lt;/p&gt;
&lt;p&gt;DFM的备份文件&lt;/p&gt;
&lt;p&gt;程序设计时&lt;/p&gt;
&lt;p&gt;DLL&lt;/p&gt;
&lt;p&gt;DYNAMIC LINK LIBRARY（动态链接库文件）&lt;/p&gt;
&lt;p&gt;编译连接时&lt;/p&gt;
&lt;p&gt;DOF&lt;/p&gt;
&lt;p&gt;DELPHI OPTION FILE，设计多语言项目时使用的语言翻译配置文件，多语言项目中每个窗体的每一种语言都有一个DNF文件&lt;/p&gt;
&lt;p&gt;程序设计时&lt;/p&gt;
&lt;p&gt;DPK&lt;/p&gt;
&lt;p&gt;DELPHI PACKAGE，软件包项目的源代码文件&lt;/p&gt;
&lt;p&gt;程序设计时&lt;/p&gt;
&lt;p&gt;DPR&lt;/p&gt;
&lt;p&gt;项目文件&lt;/p&gt;
&lt;p&gt;程序设计时&lt;/p&gt;
&lt;p&gt;~DPR&lt;/p&gt;
&lt;p&gt;DPR的备份文件&lt;/p&gt;
&lt;p&gt;程序设计时&lt;/p&gt;
&lt;p&gt;DSK&lt;/p&gt;
&lt;p&gt;DESKTOP FILE，保存现在DELPHI视窗的位置、正在编辑的文件以及其它桌面的设定文件&lt;/p&gt;
&lt;p&gt;程序设计时&lt;/p&gt;
&lt;p&gt;LIC&lt;/p&gt;
&lt;p&gt;OCX文件相关的授权文件&lt;/p&gt;
&lt;p&gt;编译连接时&lt;/p&gt;
&lt;p&gt;OCX&lt;/p&gt;
&lt;p&gt;OLE控件文件，是一特殊的DLL文件可包含ACTIVEX控件或窗体&lt;/p&gt;
&lt;p&gt;编译连接时&lt;/p&gt;
&lt;p&gt;PAS&lt;/p&gt;
&lt;p&gt;DELPHI源代码文件&lt;/p&gt;
&lt;p&gt;程序设计时&lt;/p&gt;
&lt;p&gt;~PAS&lt;/p&gt;
&lt;p&gt;PAS的备份文件&lt;/p&gt;
&lt;p&gt;程序设计时&lt;/p&gt;
&lt;p&gt;RES、RC&lt;/p&gt;
&lt;p&gt;项目的资源文件,包含项目的图标、光标及字体等信息&lt;/p&gt;
&lt;p&gt;程序设计时&lt;/p&gt;
&lt;p&gt;EXE&lt;/p&gt;
&lt;p&gt;可执行文件&lt;/p&gt;
&lt;p&gt;编译连接时&lt;/p&gt;
&lt;p&gt;TLB&lt;/p&gt;
&lt;p&gt;类型库文件&lt;/p&gt;
&lt;p&gt;程序设计时&lt;/p&gt;
&lt;h2&gt;Delphi的关键字&lt;/h2&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;array&lt;/p&gt;
&lt;p&gt;As&lt;/p&gt;
&lt;p&gt;asm&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;Case&lt;/p&gt;
&lt;p&gt;Class&lt;/p&gt;
&lt;p&gt;Const&lt;/p&gt;
&lt;p&gt;constructor&lt;/p&gt;
&lt;p&gt;destructor&lt;/p&gt;
&lt;p&gt;Dispinterface&lt;/p&gt;
&lt;p&gt;Div&lt;/p&gt;
&lt;p&gt;Do&lt;/p&gt;
&lt;p&gt;downto&lt;/p&gt;
&lt;p&gt;Else&lt;/p&gt;
&lt;p&gt;End&lt;/p&gt;
&lt;p&gt;except&lt;/p&gt;
&lt;p&gt;exports&lt;/p&gt;
&lt;p&gt;File&lt;/p&gt;
&lt;p&gt;Finalization&lt;/p&gt;
&lt;p&gt;Finally&lt;/p&gt;
&lt;p&gt;for&lt;/p&gt;
&lt;p&gt;function&lt;/p&gt;
&lt;p&gt;Goto&lt;/p&gt;
&lt;p&gt;If&lt;/p&gt;
&lt;p&gt;Implementation&lt;/p&gt;
&lt;p&gt;In&lt;/p&gt;
&lt;p&gt;inherited&lt;/p&gt;
&lt;p&gt;initialization&lt;/p&gt;
&lt;p&gt;inline&lt;/p&gt;
&lt;p&gt;Interface&lt;/p&gt;
&lt;p&gt;is&lt;/p&gt;
&lt;p&gt;label&lt;/p&gt;
&lt;p&gt;library&lt;/p&gt;
&lt;p&gt;Mod&lt;/p&gt;
&lt;p&gt;Nil&lt;/p&gt;
&lt;p&gt;not&lt;/p&gt;
&lt;p&gt;object&lt;/p&gt;
&lt;p&gt;Of&lt;/p&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;p&gt;out&lt;/p&gt;
&lt;p&gt;packed&lt;/p&gt;
&lt;p&gt;procedure&lt;/p&gt;
&lt;p&gt;program&lt;/p&gt;
&lt;p&gt;property&lt;/p&gt;
&lt;p&gt;raise&lt;/p&gt;
&lt;p&gt;record&lt;/p&gt;
&lt;p&gt;repeat&lt;/p&gt;
&lt;p&gt;resourcestring&lt;/p&gt;
&lt;p&gt;set&lt;/p&gt;
&lt;p&gt;Shl&lt;/p&gt;
&lt;p&gt;shr&lt;/p&gt;
&lt;p&gt;string&lt;/p&gt;
&lt;p&gt;then&lt;/p&gt;
&lt;p&gt;threadvar&lt;/p&gt;
&lt;p&gt;To&lt;/p&gt;
&lt;p&gt;try&lt;/p&gt;
&lt;p&gt;type&lt;/p&gt;
&lt;p&gt;unit&lt;/p&gt;
&lt;p&gt;until&lt;/p&gt;
&lt;p&gt;uses&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;while&lt;/p&gt;
&lt;p&gt;With&lt;/p&gt;
&lt;p&gt;xor&lt;/p&gt;
&lt;h2&gt;类型之间转换函数&lt;/h2&gt;
&lt;p&gt;函数 功能&lt;/p&gt;
&lt;p&gt;Chr&lt;/p&gt;
&lt;p&gt;将一个有序数据转换为一个ANSI字符&lt;/p&gt;
&lt;p&gt;Ord&lt;/p&gt;
&lt;p&gt;将一个有序类型值转换为它的序号&lt;/p&gt;
&lt;p&gt;Round&lt;/p&gt;
&lt;p&gt;转换一个实型值为四舍五入后的整型值&lt;/p&gt;
&lt;p&gt;Trunc&lt;/p&gt;
&lt;p&gt;转换一个实型值为小数截断后的整型值&lt;/p&gt;
&lt;p&gt;Int&lt;/p&gt;
&lt;p&gt;返回浮点数的整数部分&lt;/p&gt;
&lt;p&gt;IntToStr&lt;/p&gt;
&lt;p&gt;将数值转换为字符串&lt;/p&gt;
&lt;p&gt;IntToHex&lt;/p&gt;
&lt;p&gt;将数值转换为十六进制数字符串&lt;/p&gt;
&lt;p&gt;StrToInt&lt;/p&gt;
&lt;p&gt;将字符串转换为一个整型数，如字符串不是一个合法的整型将引发异常&lt;/p&gt;
&lt;p&gt;StrToIntDef&lt;/p&gt;
&lt;p&gt;将字符串转换为一个整数，如字符串不合法返回一个缺省值&lt;/p&gt;
&lt;p&gt;Val&lt;/p&gt;
&lt;p&gt;将字符串转换为一个数字（传统Turbo Pascal例程用于向后兼容）&lt;/p&gt;
&lt;p&gt;Str&lt;/p&gt;
&lt;p&gt;将数字转换为格式化字符串（传统Turbo Pascal例程用于向后兼容）&lt;/p&gt;
&lt;p&gt;StrPas&lt;/p&gt;
&lt;p&gt;将零终止字符串转换为Pascal类型字符串，在32位Delphi中这种类型转换是自动进行的&lt;/p&gt;
&lt;p&gt;StrPCopy&lt;/p&gt;
&lt;p&gt;拷贝一个Pascal类型字符串到一个零终止字符串, 在32位Delphi中这种类型转换是自动进行的&lt;/p&gt;
&lt;p&gt;StrPLCopy&lt;/p&gt;
&lt;p&gt;拷贝Pascal类型字符串的一部分到一个零终止字符串&lt;/p&gt;
&lt;p&gt;FloatToDecimal&lt;/p&gt;
&lt;p&gt;将一个浮点数转换为包含指数、数字及符号的十进制浮点记录类型&lt;/p&gt;
&lt;p&gt;FloatToStr&lt;/p&gt;
&lt;p&gt;将浮点值转换为缺省格式的字符串&lt;/p&gt;
&lt;p&gt;FloatToStrF&lt;/p&gt;
&lt;p&gt;将浮点值转换为特定格式的字符串&lt;/p&gt;
&lt;p&gt;FloatToText&lt;/p&gt;
&lt;p&gt;使用特定格式，将一个浮点值拷贝到一个字符串缓冲区&lt;/p&gt;
&lt;p&gt;FloatToTextFmt&lt;/p&gt;
&lt;p&gt;同上面例程，使用特定格式，将一个浮点值拷贝到一个字符串缓冲区&lt;/p&gt;
&lt;p&gt;StrToFloat&lt;/p&gt;
&lt;p&gt;将一个Pascal字符串转换为浮点数&lt;/p&gt;
&lt;p&gt;TextToFloat&lt;/p&gt;
&lt;p&gt;将一个零终止字符串转换为浮点数&lt;/p&gt;
&lt;h2&gt;组件的常用属性&lt;/h2&gt;
&lt;p&gt;属性 说明&lt;/p&gt;
&lt;p&gt;Height&lt;/p&gt;
&lt;p&gt;高度&lt;/p&gt;
&lt;p&gt;Width&lt;/p&gt;
&lt;p&gt;宽度&lt;/p&gt;
&lt;p&gt;Left&lt;/p&gt;
&lt;p&gt;组件在容器内的水平坐标，相对于容器左边。&lt;/p&gt;
&lt;p&gt;Top&lt;/p&gt;
&lt;p&gt;组件在容器内的垂直坐标，相对于容器上边。&lt;/p&gt;
&lt;p&gt;Align&lt;/p&gt;
&lt;p&gt;组件上的对齐方式（居上、居下、居左、居右、居中）&lt;/p&gt;
&lt;p&gt;Visible&lt;/p&gt;
&lt;p&gt;设置组件是否可见，默认值为可见（值为true）&lt;/p&gt;
&lt;p&gt;Caption&lt;/p&gt;
&lt;p&gt;显示类组件的标题&lt;/p&gt;
&lt;p&gt;Color&lt;/p&gt;
&lt;p&gt;组件的背景颜色&lt;/p&gt;
&lt;p&gt;Font&lt;/p&gt;
&lt;p&gt;设置组件显示文本的字体&lt;/p&gt;
&lt;p&gt;Ctl3D&lt;/p&gt;
&lt;p&gt;是否以3D方式显示组件，默认值为true&lt;/p&gt;
&lt;p&gt;ShowHint&lt;/p&gt;
&lt;p&gt;是否显示组件的提示信息，默认值为true，与Hint连用&lt;/p&gt;
&lt;p&gt;Hint&lt;/p&gt;
&lt;p&gt;当鼠标指针移到组件上时，组件显示的提示信息&lt;/p&gt;
&lt;p&gt;Enabled&lt;/p&gt;
&lt;p&gt;是否允许用户操作组件，true表示允许，false表示不允许&lt;/p&gt;
&lt;p&gt;Name&lt;/p&gt;
&lt;p&gt;用于标识组件的名称，在程序中通过Name可以调用该组件&lt;/p&gt;
&lt;p&gt;TabOrder&lt;/p&gt;
&lt;p&gt;Tab次序&lt;/p&gt;
&lt;h2&gt;组件的常用事件&lt;/h2&gt;
&lt;p&gt;事件 说明&lt;/p&gt;
&lt;p&gt;OnClick&lt;/p&gt;
&lt;p&gt;触发条件&lt;/p&gt;
&lt;p&gt;OnDblClick&lt;/p&gt;
&lt;p&gt;当鼠标双击时触发本事件&lt;/p&gt;
&lt;p&gt;OnMouseDown&lt;/p&gt;
&lt;p&gt;当鼠标左键按下时触发本事件&lt;/p&gt;
&lt;p&gt;OnMouseMove&lt;/p&gt;
&lt;p&gt;当鼠标移动时触发本事件&lt;/p&gt;
&lt;p&gt;OnKeyDown&lt;/p&gt;
&lt;p&gt;当按下任意键（包括组合键）时触发本事件&lt;/p&gt;
&lt;p&gt;OnKeyPress&lt;/p&gt;
&lt;p&gt;当按下任意键（单字符键）时触发本事件&lt;/p&gt;
&lt;p&gt;OnKeyUp&lt;/p&gt;
&lt;p&gt;当松开已按下键时触发本事件&lt;/p&gt;
&lt;p&gt;OnEnter&lt;/p&gt;
&lt;p&gt;当获得焦点时触发本事件&lt;/p&gt;
&lt;p&gt;OnExit&lt;/p&gt;
&lt;p&gt;当失去焦点时触发本事件&lt;/p&gt;
&lt;p&gt;OnStartDrag&lt;/p&gt;
&lt;p&gt;当开始拖动时触发本事件&lt;/p&gt;
&lt;p&gt;OnDragDrop&lt;/p&gt;
&lt;p&gt;当组件拖动操作结束时触发本事件&lt;/p&gt;
&lt;h2&gt;常用类型和函数的uses单元&lt;/h2&gt;
&lt;p&gt;Type Unit&lt;/p&gt;
&lt;p&gt;_Stream&lt;/p&gt;
&lt;p&gt;ADODB_TLB&lt;/p&gt;
&lt;p&gt;akTop, akLeft, akRight, akBottom&lt;/p&gt;
&lt;p&gt;Controls&lt;/p&gt;
&lt;p&gt;Application (the variable not a type)&lt;/p&gt;
&lt;p&gt;Forms&lt;/p&gt;
&lt;p&gt;Beep&lt;/p&gt;
&lt;p&gt;SysUtils or Windows (different functions)&lt;/p&gt;
&lt;p&gt;CGID_EXPLORER&lt;/p&gt;
&lt;p&gt;ShlObj&lt;/p&gt;
&lt;p&gt;CN_BASE&lt;/p&gt;
&lt;p&gt;Controls&lt;/p&gt;
&lt;p&gt;CoInitialize&lt;/p&gt;
&lt;p&gt;ActiveX&lt;/p&gt;
&lt;p&gt;CopyFile&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;CoUnInitialize&lt;/p&gt;
&lt;p&gt;ActiveX&lt;/p&gt;
&lt;p&gt;CreateComObject&lt;/p&gt;
&lt;p&gt;ComObj&lt;/p&gt;
&lt;p&gt;CreateOleObject&lt;/p&gt;
&lt;p&gt;ComObj&lt;/p&gt;
&lt;p&gt;Date&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;DeleteFile&lt;/p&gt;
&lt;p&gt;SysUtils or Windows (different versions)&lt;/p&gt;
&lt;p&gt;DispatchInvokeError&lt;/p&gt;
&lt;p&gt;ComObj&lt;/p&gt;
&lt;p&gt;DWORD&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;EDatabaseError&lt;/p&gt;
&lt;p&gt;DB&lt;/p&gt;
&lt;p&gt;EncodeDateTime&lt;/p&gt;
&lt;p&gt;DateUtils&lt;/p&gt;
&lt;p&gt;EnumWindows&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;EOleError&lt;/p&gt;
&lt;p&gt;ComObj&lt;/p&gt;
&lt;p&gt;EOleException&lt;/p&gt;
&lt;p&gt;ComObj&lt;/p&gt;
&lt;p&gt;EOleSysError&lt;/p&gt;
&lt;p&gt;ComObj&lt;/p&gt;
&lt;p&gt;Exception&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;ExtractFileName&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;FileExists&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;FileOpen&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;FILETIME&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;FindFirst&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;FindFirstFile&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;FindWindow&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;FlushFileBuffers&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;fmOpenRead&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;fmShareDenyWrite&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;Format&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;FormatDateTime&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;FreeAndNil&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;fsBold&lt;/p&gt;
&lt;p&gt;Graphics&lt;/p&gt;
&lt;p&gt;ftWideString&lt;/p&gt;
&lt;p&gt;DB&lt;/p&gt;
&lt;p&gt;ftString&lt;/p&gt;
&lt;p&gt;DB&lt;/p&gt;
&lt;p&gt;GetCurrentProcessId&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;GetEnvironmentVariable&lt;/p&gt;
&lt;p&gt;SysUtils or Windows (different versions)&lt;/p&gt;
&lt;p&gt;GetFileAttributes&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;GetFileVersionInfoSize&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;GetWindowLong&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;GetStdHandle&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;HDC&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;HFont&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;HINTERNET&lt;/p&gt;
&lt;p&gt;WinInet&lt;/p&gt;
&lt;p&gt;HKEY_CURRENT_USER&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;IHTMLDocument2&lt;/p&gt;
&lt;p&gt;MSHTML or MSHTML_TLB&lt;/p&gt;
&lt;p&gt;IHTMLElement&lt;/p&gt;
&lt;p&gt;MSHTML or MSHTML_TLB&lt;/p&gt;
&lt;p&gt;IHTMLEventObj&lt;/p&gt;
&lt;p&gt;MSHTML or MSHTML_TLB&lt;/p&gt;
&lt;p&gt;IID_IWebBrowser2&lt;/p&gt;
&lt;p&gt;SHDocVw or SHDocVw_TLB&lt;/p&gt;
&lt;p&gt;IMessage&lt;/p&gt;
&lt;p&gt;CDO_TLB&lt;/p&gt;
&lt;p&gt;InternetClosehandle&lt;/p&gt;
&lt;p&gt;WinInet&lt;/p&gt;
&lt;p&gt;InternetOpenUrl&lt;/p&gt;
&lt;p&gt;WinInet&lt;/p&gt;
&lt;p&gt;InternetReadFile&lt;/p&gt;
&lt;p&gt;WinInet&lt;/p&gt;
&lt;p&gt;IntToHex&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;IntToStr&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;IOleCommandTarget&lt;/p&gt;
&lt;p&gt;ActiveX&lt;/p&gt;
&lt;p&gt;IOleContainer&lt;/p&gt;
&lt;p&gt;ActiveX&lt;/p&gt;
&lt;p&gt;IPersistStreamInit&lt;/p&gt;
&lt;p&gt;ActiveX&lt;/p&gt;
&lt;p&gt;IsSameDay&lt;/p&gt;
&lt;p&gt;DateUtils&lt;/p&gt;
&lt;p&gt;IStream&lt;/p&gt;
&lt;p&gt;ActiveX&lt;/p&gt;
&lt;p&gt;IWebBrowser2&lt;/p&gt;
&lt;p&gt;SHDocVw or SHDocVw_TLB&lt;/p&gt;
&lt;p&gt;LockWindowUpdate&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;Log10&lt;/p&gt;
&lt;p&gt;Math&lt;/p&gt;
&lt;p&gt;LowerCase&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;LPSTR&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;MAX_PATH&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;MessageBox&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;MessageDlg&lt;/p&gt;
&lt;p&gt;Dialogs&lt;/p&gt;
&lt;p&gt;MB_YESNO, MB_OK etc&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;MinutesBetween&lt;/p&gt;
&lt;p&gt;DateUtils&lt;/p&gt;
&lt;p&gt;Now&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;OleInitialize&lt;/p&gt;
&lt;p&gt;ActiveX&lt;/p&gt;
&lt;p&gt;OleUninitialize&lt;/p&gt;
&lt;p&gt;ActiveX&lt;/p&gt;
&lt;p&gt;PItemIDList&lt;/p&gt;
&lt;p&gt;ShlObj&lt;/p&gt;
&lt;p&gt;POleCmd&lt;/p&gt;
&lt;p&gt;ActiveX&lt;/p&gt;
&lt;p&gt;POleCmdText&lt;/p&gt;
&lt;p&gt;ActiveX&lt;/p&gt;
&lt;p&gt;PostMessage&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;PosX&lt;/p&gt;
&lt;p&gt;StrUtils&lt;/p&gt;
&lt;p&gt;QueryHighPerformanceCounter&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;QueryPerformanceCounter&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;ReverseString&lt;/p&gt;
&lt;p&gt;StrUtils&lt;/p&gt;
&lt;p&gt;RoundTo&lt;/p&gt;
&lt;p&gt;Math&lt;/p&gt;
&lt;p&gt;SendMessage&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;SetForegroundWindow&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;ShellExecute&lt;/p&gt;
&lt;p&gt;ShellAPI&lt;/p&gt;
&lt;p&gt;ShellExecuteEx&lt;/p&gt;
&lt;p&gt;ShellAPI&lt;/p&gt;
&lt;p&gt;SHGetFileInfo&lt;/p&gt;
&lt;p&gt;ShellAPI&lt;/p&gt;
&lt;p&gt;SHFILEINFO&lt;/p&gt;
&lt;p&gt;ShellAPI&lt;/p&gt;
&lt;p&gt;ShowMessage&lt;/p&gt;
&lt;p&gt;Dialogs&lt;/p&gt;
&lt;p&gt;Sleep&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;StrAlloc&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;StrPas&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;StrToDate&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;StrToInt&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;StrToIntDef&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;TAdoConnection&lt;/p&gt;
&lt;p&gt;ADODB&lt;/p&gt;
&lt;p&gt;TAdoQuery&lt;/p&gt;
&lt;p&gt;ADODB&lt;/p&gt;
&lt;p&gt;TAlign&lt;/p&gt;
&lt;p&gt;Controls&lt;/p&gt;
&lt;p&gt;TAlignment&lt;/p&gt;
&lt;p&gt;Classes&lt;/p&gt;
&lt;p&gt;TAnchors&lt;/p&gt;
&lt;p&gt;Controls&lt;/p&gt;
&lt;p&gt;TBitmap&lt;/p&gt;
&lt;p&gt;Graphics&lt;/p&gt;
&lt;p&gt;TBlobStream&lt;/p&gt;
&lt;p&gt;DBTables&lt;/p&gt;
&lt;p&gt;TCanvas&lt;/p&gt;
&lt;p&gt;Graphics&lt;/p&gt;
&lt;p&gt;TClientSocket&lt;/p&gt;
&lt;p&gt;ScktComp&lt;/p&gt;
&lt;p&gt;TComboBox&lt;/p&gt;
&lt;p&gt;StdCtrls&lt;/p&gt;
&lt;p&gt;TComponent&lt;/p&gt;
&lt;p&gt;Classes&lt;/p&gt;
&lt;p&gt;TControl&lt;/p&gt;
&lt;p&gt;Controls or QControls&lt;/p&gt;
&lt;p&gt;TCriticalSection&lt;/p&gt;
&lt;p&gt;SyncObjs&lt;/p&gt;
&lt;p&gt;TField&lt;/p&gt;
&lt;p&gt;DB&lt;/p&gt;
&lt;p&gt;TFieldType&lt;/p&gt;
&lt;p&gt;DB&lt;/p&gt;
&lt;p&gt;TFileName&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;TFileStream&lt;/p&gt;
&lt;p&gt;Classes&lt;/p&gt;
&lt;p&gt;TForm&lt;/p&gt;
&lt;p&gt;Forms&lt;/p&gt;
&lt;p&gt;TFrame&lt;/p&gt;
&lt;p&gt;Forms&lt;/p&gt;
&lt;p&gt;TGroupBox&lt;/p&gt;
&lt;p&gt;StdCtrls&lt;/p&gt;
&lt;p&gt;TIID&lt;/p&gt;
&lt;p&gt;ActiveX&lt;/p&gt;
&lt;p&gt;TIniFile&lt;/p&gt;
&lt;p&gt;IniFiles&lt;/p&gt;
&lt;p&gt;TJPEGImage&lt;/p&gt;
&lt;p&gt;Jpeg&lt;/p&gt;
&lt;p&gt;TLabel&lt;/p&gt;
&lt;p&gt;StdCtrls&lt;/p&gt;
&lt;p&gt;TList&lt;/p&gt;
&lt;p&gt;Classes&lt;/p&gt;
&lt;p&gt;TMemo&lt;/p&gt;
&lt;p&gt;StdCtrls&lt;/p&gt;
&lt;p&gt;TMemoryStream&lt;/p&gt;
&lt;p&gt;Classes&lt;/p&gt;
&lt;p&gt;TMouseButton&lt;/p&gt;
&lt;p&gt;Controls&lt;/p&gt;
&lt;p&gt;TNofityEvent&lt;/p&gt;
&lt;p&gt;Classes&lt;/p&gt;
&lt;p&gt;TObjectList&lt;/p&gt;
&lt;p&gt;Contnrs&lt;/p&gt;
&lt;p&gt;TOSVersionInfo&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;TPanel&lt;/p&gt;
&lt;p&gt;ExtCtrls&lt;/p&gt;
&lt;p&gt;TPoint&lt;/p&gt;
&lt;p&gt;Types&lt;/p&gt;
&lt;p&gt;TProcessEntry32&lt;/p&gt;
&lt;p&gt;TlHelp32&lt;/p&gt;
&lt;p&gt;TProgressBar&lt;/p&gt;
&lt;p&gt;ComCtrls or QComCtrls&lt;/p&gt;
&lt;p&gt;TRadioButton&lt;/p&gt;
&lt;p&gt;StdCtrls&lt;/p&gt;
&lt;p&gt;TRadioGroup&lt;/p&gt;
&lt;p&gt;ExtCtrls&lt;/p&gt;
&lt;p&gt;TRect&lt;/p&gt;
&lt;p&gt;Types&lt;/p&gt;
&lt;p&gt;TRegistry&lt;/p&gt;
&lt;p&gt;Registry&lt;/p&gt;
&lt;p&gt;Trim&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;TRoundToRange&lt;/p&gt;
&lt;p&gt;Math&lt;/p&gt;
&lt;p&gt;TSearchRec&lt;/p&gt;
&lt;p&gt;SysUtils&lt;/p&gt;
&lt;p&gt;TSize&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;TSocketAddrIn&lt;/p&gt;
&lt;p&gt;Winsock&lt;/p&gt;
&lt;p&gt;TStaticText&lt;/p&gt;
&lt;p&gt;StdCtrls&lt;/p&gt;
&lt;p&gt;TStream&lt;/p&gt;
&lt;p&gt;Classes&lt;/p&gt;
&lt;p&gt;TStringList&lt;/p&gt;
&lt;p&gt;Classes&lt;/p&gt;
&lt;p&gt;TStrings&lt;/p&gt;
&lt;p&gt;Classes&lt;/p&gt;
&lt;p&gt;TStringStream&lt;/p&gt;
&lt;p&gt;Classes&lt;/p&gt;
&lt;p&gt;TSystemTime&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;TTable&lt;/p&gt;
&lt;p&gt;DBTables&lt;/p&gt;
&lt;p&gt;TTabSheet&lt;/p&gt;
&lt;p&gt;ComCtrls&lt;/p&gt;
&lt;p&gt;TThread&lt;/p&gt;
&lt;p&gt;Classes&lt;/p&gt;
&lt;p&gt;TTreeNode&lt;/p&gt;
&lt;p&gt;ComCtrls&lt;/p&gt;
&lt;p&gt;TWebBrowser&lt;/p&gt;
&lt;p&gt;SHDocVw or SHDocVw_TLB&lt;/p&gt;
&lt;p&gt;TWinSocketStream&lt;/p&gt;
&lt;p&gt;ScktComp&lt;/p&gt;
&lt;p&gt;TWMCommand&lt;/p&gt;
&lt;p&gt;Messages&lt;/p&gt;
&lt;p&gt;Unassigned&lt;/p&gt;
&lt;p&gt;Variants&lt;/p&gt;
&lt;p&gt;VarArrayCreate&lt;/p&gt;
&lt;p&gt;Variants&lt;/p&gt;
&lt;p&gt;VarArrayOf&lt;/p&gt;
&lt;p&gt;Variants&lt;/p&gt;
&lt;p&gt;VirtualProtect&lt;/p&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;p&gt;WM_USER&lt;/p&gt;
&lt;p&gt;Messages&lt;/p&gt;
&lt;p&gt;YearOf&lt;/p&gt;
&lt;p&gt;DateUtils&lt;/p&gt;
&lt;h2&gt;Delphi常用的ADO组件&lt;/h2&gt;
&lt;p&gt;ADO组件 作用&lt;/p&gt;
&lt;p&gt;TADOConnection&lt;/p&gt;
&lt;p&gt;该组件用于建立数据库的连接。&lt;/p&gt;
&lt;p&gt;TADODataSet&lt;/p&gt;
&lt;p&gt;这是ADO提取及操作数据库数据的主要数据集，该组件可以从一个或多个基表中提取数据。&lt;/p&gt;
&lt;p&gt;TADOTable&lt;/p&gt;
&lt;p&gt;主要用于操作和提取单个基表的数据。&lt;/p&gt;
&lt;p&gt;TADOQuery&lt;/p&gt;
&lt;p&gt;该组件是通过SQL语句实现对数据库数据的提取及操作。&lt;/p&gt;
&lt;p&gt;TADOStoredProc&lt;/p&gt;
&lt;p&gt;该数据集是专门用于运行数据库中的存储过程的。&lt;/p&gt;
&lt;p&gt;TADOCommand&lt;/p&gt;
&lt;p&gt;该组件用于运行一些SQL命令。&lt;/p&gt;
&lt;p&gt;RDSConnection&lt;/p&gt;
&lt;p&gt;一个进程或一台计算机传递到另一个进程或计算机的数据集合，用于远程数据访问。&lt;/p&gt;
&lt;h2&gt;ADO组件常用属性&lt;/h2&gt;
&lt;p&gt;属 性 说明&lt;/p&gt;
&lt;p&gt;Active&lt;/p&gt;
&lt;p&gt;Active属性指定数据集是否处于打开状态。设置Active属性为True,则数据集被打开；设置Active属性为False，则数据集被关闭。&lt;/p&gt;
&lt;p&gt;State&lt;/p&gt;
&lt;p&gt;State属性表明了当前数据集的状态&lt;/p&gt;
&lt;p&gt;CacheSize&lt;/p&gt;
&lt;p&gt;指定数据集的缓冲区大小。&lt;/p&gt;
&lt;p&gt;CommandTimeout&lt;/p&gt;
&lt;p&gt;CommandTimeout属性是一个整型数，指定执行一个命令的最大允许时间，默认值是30秒。&lt;/p&gt;
&lt;p&gt;Connection&lt;/p&gt;
&lt;p&gt;指定所使用的数据源连接组件的名称，即TADOConnection 组件的名称。&lt;/p&gt;
&lt;p&gt;ConnectionString&lt;/p&gt;
&lt;p&gt;即连接字符串，用于指定数据库的连接信息。&lt;/p&gt;
&lt;p&gt;CursorLocation&lt;/p&gt;
&lt;p&gt;指定数据库记录指针是采用客户端模式还是服务器端模式。&lt;/p&gt;
&lt;p&gt;CursorType&lt;/p&gt;
&lt;p&gt;指定在数据集中使用的记录指针类型。&lt;/p&gt;
&lt;p&gt;AutoCalcFields&lt;/p&gt;
&lt;p&gt;设为 True 则允许应用程序触发OnCalcFields事件。&lt;/p&gt;
&lt;p&gt;BOF&lt;/p&gt;
&lt;p&gt;为True时，表示当前指针指向第一条记录,否则为False。&lt;/p&gt;
&lt;p&gt;EOF&lt;/p&gt;
&lt;p&gt;为True时，表示当前指针指向最后一条记录,否则为False。&lt;/p&gt;
&lt;p&gt;Bookmark&lt;/p&gt;
&lt;p&gt;在数据集中设定标记，用于在一个数据集中获得或者设置当前记录。&lt;/p&gt;
&lt;p&gt;Filter&lt;/p&gt;
&lt;p&gt;设置过滤条件。&lt;/p&gt;
&lt;p&gt;Filtered&lt;/p&gt;
&lt;p&gt;相当于过滤的开关，当Filtered属性的值为True时，数据集从数据库中获取符合条件的记录；当Filtered属性的值为False时不执行过滤。&lt;/p&gt;
&lt;p&gt;FilterOptions&lt;/p&gt;
&lt;p&gt;确定过滤方式。&lt;/p&gt;
&lt;p&gt;FieldCount&lt;/p&gt;
&lt;p&gt;返回该数据集的字段数。&lt;/p&gt;
&lt;p&gt;FieldDefList&lt;/p&gt;
&lt;p&gt;返回数据集字段定义列表。&lt;/p&gt;
&lt;p&gt;FieldDefs&lt;/p&gt;
&lt;p&gt;表明数据集中字段的定义信息。如字段的数据类型、数据长度、名称等。&lt;/p&gt;
&lt;p&gt;FieldList&lt;/p&gt;
&lt;p&gt;数据集中字段组件的连续列表。&lt;/p&gt;
&lt;p&gt;Fields&lt;/p&gt;
&lt;p&gt;数据集中字段的集合，用于访问数据集中的字段。&lt;/p&gt;
&lt;p&gt;FieldValues&lt;/p&gt;
&lt;p&gt;可访问当前记录所有字段值列表。&lt;/p&gt;
&lt;p&gt;Found&lt;/p&gt;
&lt;p&gt;表示FindFirst、FindNext、FindLast或者FindPrior是否成功。&lt;/p&gt;
&lt;p&gt;IndexName&lt;/p&gt;
&lt;p&gt;指定当前使用的索引。&lt;/p&gt;
&lt;p&gt;LockType&lt;/p&gt;
&lt;p&gt;指定了数据集打开数据库时，对数据表中的记录的锁定类型。&lt;/p&gt;
&lt;p&gt;MaxRecords&lt;/p&gt;
&lt;p&gt;指定记录集中一次允许从数据库中返回的最大记录数。 默认值为0，表示不限制返回行数。&lt;/p&gt;
&lt;p&gt;Modified&lt;/p&gt;
&lt;p&gt;表示数据集是否被更改了。布尔型。&lt;/p&gt;
&lt;p&gt;Name&lt;/p&gt;
&lt;p&gt;数据集组件名称&lt;/p&gt;
&lt;p&gt;RecNo&lt;/p&gt;
&lt;p&gt;数据集的记录号。&lt;/p&gt;
&lt;p&gt;RecordCount&lt;/p&gt;
&lt;p&gt;与数据集相关的记录总数。&lt;/p&gt;
&lt;p&gt;RecordSize&lt;/p&gt;
&lt;p&gt;表示数据集中记录缓冲区的大小。&lt;/p&gt;
&lt;h2&gt;ADO数据集类组件的共同方法&lt;/h2&gt;
&lt;p&gt;方法 说明&lt;/p&gt;
&lt;p&gt;ActiveBuffer&lt;/p&gt;
&lt;p&gt;返回一个PChar，包含激活记录的数据&lt;/p&gt;
&lt;p&gt;Append&lt;/p&gt;
&lt;p&gt;添加一个新的记录到数据集中&lt;/p&gt;
&lt;p&gt;AppendRecord&lt;/p&gt;
&lt;p&gt;添加一个新的记录到数据集中。以数组参数传递来的值填充字段&lt;/p&gt;
&lt;p&gt;BookmarkValid&lt;/p&gt;
&lt;p&gt;该方法传递一个Bookmark参数，如果此Bookmark在数据集中有效则返回True&lt;/p&gt;
&lt;p&gt;Cancel&lt;/p&gt;
&lt;p&gt;取消对数据集的修改，并设置数据集的状态为dsBrowse&lt;/p&gt;
&lt;p&gt;CancelBatch&lt;/p&gt;
&lt;p&gt;在批更新模式下，撤销一批正等待处理的更新&lt;/p&gt;
&lt;p&gt;CancelUpdates&lt;/p&gt;
&lt;p&gt;撤消一个准备执行的更新操作。用于一般更新模式，在Post执行之前调用&lt;/p&gt;
&lt;p&gt;Clone&lt;/p&gt;
&lt;p&gt;克隆另外一个数据集到当前调用组件&lt;/p&gt;
&lt;p&gt;CheckBrowseMode&lt;/p&gt;
&lt;p&gt;当前记录更改时，自动提交或取消数据更改。&lt;/p&gt;
&lt;p&gt;ClearFields&lt;/p&gt;
&lt;p&gt;清除激活记录的所有字段值&lt;/p&gt;
&lt;p&gt;Close&lt;/p&gt;
&lt;p&gt;关闭数据集&lt;/p&gt;
&lt;p&gt;CompareBookmarks&lt;/p&gt;
&lt;p&gt;比较两个书签，如果这两个书签引用同样的记录则返回0，如果第一个书签指定所引用的记录在数据集中的位置比第二个书签在数据集中的位置靠前则返回一个小于0的值，否则
返回一个大于0的值&lt;/p&gt;
&lt;p&gt;ControlsDisabled&lt;/p&gt;
&lt;p&gt;Boolean特性，表示相应的控件是否失效&lt;/p&gt;
&lt;p&gt;方法&lt;/p&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;p&gt;Create&lt;/p&gt;
&lt;p&gt;构造函数&lt;/p&gt;
&lt;p&gt;CreateBlobStream&lt;/p&gt;
&lt;p&gt;从一个Field参数创建一个BlobStream&lt;/p&gt;
&lt;p&gt;CursorPosChanged&lt;/p&gt;
&lt;p&gt;使内部光标定位无效&lt;/p&gt;
&lt;p&gt;Delete&lt;/p&gt;
&lt;p&gt;删除当前的记录&lt;/p&gt;
&lt;p&gt;DeleteRecords&lt;/p&gt;
&lt;p&gt;删除记录集中的一行或多行记录。&lt;/p&gt;
&lt;p&gt;Destroy&lt;/p&gt;
&lt;p&gt;析构函数&lt;/p&gt;
&lt;p&gt;DisableControls&lt;/p&gt;
&lt;p&gt;在更新过程中使相应的控件无效&lt;/p&gt;
&lt;p&gt;Edit&lt;/p&gt;
&lt;p&gt;将记录的状态设置为dsEdit；记录在编辑模式下&lt;/p&gt;
&lt;p&gt;EnableControls&lt;/p&gt;
&lt;p&gt;使相应的控件有效&lt;/p&gt;
&lt;p&gt;FieldByName&lt;/p&gt;
&lt;p&gt;返回动态的TField，通过字段名搜索&lt;/p&gt;
&lt;p&gt;FindField&lt;/p&gt;
&lt;p&gt;如果找到指定的字段名则返回一个TField；否则返回nil&lt;/p&gt;
&lt;p&gt;FindFirst&lt;/p&gt;
&lt;p&gt;返回一个Boolean值，表示查找的成功或者失败；将光标定位在数据集中的第一个记录上&lt;/p&gt;
&lt;p&gt;FindLast&lt;/p&gt;
&lt;p&gt;返回一个Boolean值，表示查找的成功或者失败；将光标定位在数据集中的最后一个记录上&lt;/p&gt;
&lt;p&gt;FindNext&lt;/p&gt;
&lt;p&gt;返回一个Boolean值，表示查找的成功或者失败；将光标定位在数据集中当前记录的下一个记录上&lt;/p&gt;
&lt;p&gt;方法&lt;/p&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;p&gt;FindPrior&lt;/p&gt;
&lt;p&gt;返回一个Boolean值，表示查找的成功或者失败；将光标定位在数据集中当前记录的前一个记录上&lt;/p&gt;
&lt;p&gt;First&lt;/p&gt;
&lt;p&gt;将光标定位在第一条记录上&lt;/p&gt;
&lt;p&gt;FreeBookmark&lt;/p&gt;
&lt;p&gt;该方法传递一个用GetBookmark方法返回的书签，释放这个书签&lt;/p&gt;
&lt;p&gt;GetBlobFieldData&lt;/p&gt;
&lt;p&gt;返回BLOB字段值，根据FieldNo将值返回到一个字节数组：TBlobFieldData&lt;/p&gt;
&lt;p&gt;GetBookmark&lt;/p&gt;
&lt;p&gt;返回代表当前记录的书签&lt;/p&gt;
&lt;p&gt;GetCurrentRecord&lt;/p&gt;
&lt;p&gt;返回一个Boolean值，表示Buffer参数是否被当前记录缓冲区的值所填充&lt;/p&gt;
&lt;p&gt;GetDetailDataSets&lt;/p&gt;
&lt;p&gt;用每一个嵌套的数据集填充TList参数&lt;/p&gt;
&lt;p&gt;GetDetailLinkFields&lt;/p&gt;
&lt;p&gt;用字段组件（此组件构成了一个主细节关系）填充两个TList参数&lt;/p&gt;
&lt;p&gt;GetFieldData&lt;/p&gt;
&lt;p&gt;如果成功的话以字段数据填充一个缓冲区&lt;/p&gt;
&lt;p&gt;GetFieldList&lt;/p&gt;
&lt;p&gt;将所有由FieldNames参数指定的字段组件拷贝到TList参数中&lt;/p&gt;
&lt;p&gt;GetFieldNames&lt;/p&gt;
&lt;p&gt;返回数据集中所有字段名的一个列表，保存在TStrings参数中&lt;/p&gt;
&lt;p&gt;GetIndexNames&lt;/p&gt;
&lt;p&gt;获取当前数据集的索引名称的列表。&lt;/p&gt;
&lt;p&gt;GotoBookmark&lt;/p&gt;
&lt;p&gt;将光标定位到由Bookmark参数指定的记录中&lt;/p&gt;
&lt;p&gt;Insert&lt;/p&gt;
&lt;p&gt;将数据集设置为插入模式（State = dsInsert）&lt;/p&gt;
&lt;p&gt;InsertRecord&lt;/p&gt;
&lt;p&gt;插入一个记录，字段值由传递过来的变体数的常量数组填充&lt;/p&gt;
&lt;p&gt;方法&lt;/p&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;p&gt;IsEmpty&lt;/p&gt;
&lt;p&gt;一个Boolean值，表示数据集是否为空&lt;/p&gt;
&lt;p&gt;IsLinkedTo&lt;/p&gt;
&lt;p&gt;如果数据集已经连接到参数TDataSource，则返回True&lt;/p&gt;
&lt;p&gt;IsSequenced&lt;/p&gt;
&lt;p&gt;如果数据库表格由数据集表示则返回True，表示记录号码是否代表记录的顺序&lt;/p&gt;
&lt;p&gt;Last&lt;/p&gt;
&lt;p&gt;将光标定位到数据集中的最后一个记录&lt;/p&gt;
&lt;p&gt;LoadFromFile&lt;/p&gt;
&lt;p&gt;从一个文件中读以数据到ADO数据集中。&lt;/p&gt;
&lt;p&gt;Locate&lt;/p&gt;
&lt;p&gt;定位一条记录并把这条记录作为当前记录。如果找到记录则返回True&lt;/p&gt;
&lt;p&gt;Lookup&lt;/p&gt;
&lt;p&gt;由找到的记录中返回指定字段的值&lt;/p&gt;
&lt;p&gt;MoveBy&lt;/p&gt;
&lt;p&gt;将光标定位到由当前记录加上偏移量所代表的记录上&lt;/p&gt;
&lt;p&gt;Next&lt;/p&gt;
&lt;p&gt;将光标定位到下一个记录&lt;/p&gt;
&lt;p&gt;Open&lt;/p&gt;
&lt;p&gt;打开数据集&lt;/p&gt;
&lt;p&gt;Post&lt;/p&gt;
&lt;p&gt;将记录中的修改发送到数据库&lt;/p&gt;
&lt;p&gt;Prior&lt;/p&gt;
&lt;p&gt;将光标定位到前一个记录&lt;/p&gt;
&lt;p&gt;Refresh&lt;/p&gt;
&lt;p&gt;重新从数据库读取数据&lt;/p&gt;
&lt;p&gt;Requery&lt;/p&gt;
&lt;p&gt;刷新记录集，可以保持数据集的数据和数据库一致&lt;/p&gt;
&lt;p&gt;Resync&lt;/p&gt;
&lt;p&gt;从数据库中重新获取前一个、当前的和下一个记录&lt;/p&gt;</summary><category term=""></category></entry><entry><title>Delphi学习笔记04</title><link href="/2009/12/delphi-study-notes-04/" rel="alternate"></link><updated>2009-12-01T00:00:00+08:00</updated><author><name>alswl</name></author><id>tag:,2009-12-01:2009/12/delphi-study-notes-04/</id><summary type="html">&lt;p&gt;今天主要学习了Object Pascal的&lt;strong&gt;面向对象&lt;/strong&gt;部分：类的定义、继承、多态这些基本操作。&lt;/p&gt;
&lt;p&gt;1.Delphi的关键词好麻烦，居然result都没法用，返回值的错误我查找了很久才明白为什么编译器说result重定义。&lt;/p&gt;
&lt;p&gt;2.语法结构严谨，比如类定义必须在&lt;code&gt;interface&lt;/code&gt;之后，过程/函数的实现必须要分开，而无法写成C++/Java那种inner类定义，写起来难免缚手缚脚
。&lt;/p&gt;
&lt;p&gt;3.大小写的语法规范很麻烦，像&lt;code&gt;Integer/String&lt;/code&gt;这些关键词，我真不知道该不该首字母大写。还有变量的定义，按照"Delphi编码规范"是应该大写
，可是这样就需要频繁的使用Shift，还是喜欢Java的那种首字符小写的驼峰式，能够清楚地把函数/过程/变量区分开。&lt;/p&gt;
&lt;p&gt;4.&lt;code&gt;fuction/procedure&lt;/code&gt;除了返回值又没什么大区别，现在想来真爱死void了。&lt;/p&gt;
&lt;p&gt;下面上今天学习的代码，是类的&lt;strong&gt;定义&lt;/strong&gt;、&lt;strong&gt;继承&lt;/strong&gt;、&lt;strong&gt;多态&lt;/strong&gt;这些。&lt;/p&gt;
&lt;h2&gt;1.类的使用&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;unit&lt;/span&gt; &lt;span class="n"&gt;USharp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{接口定义}&lt;/p&gt;
&lt;p&gt;interface&lt;/p&gt;
&lt;p&gt;type&lt;/p&gt;
&lt;p&gt;{定义类TSharp}&lt;/p&gt;
&lt;p&gt;TSharp = class(TObject)&lt;/p&gt;
&lt;p&gt;private&lt;/p&gt;
&lt;p&gt;FWeight : Double;&lt;/p&gt;
&lt;p&gt;procedure SetWeight(Weight : Double);&lt;/p&gt;
&lt;p&gt;public&lt;/p&gt;
&lt;p&gt;{定义属性Weight}&lt;/p&gt;
&lt;p&gt;property Weight : Double read FWeight write SetWeight;&lt;/p&gt;
&lt;p&gt;procedure Display();&lt;/p&gt;
&lt;p&gt;procedure Draw() ;virtual;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;{实现}&lt;/p&gt;
&lt;p&gt;implementation&lt;/p&gt;
&lt;p&gt;procedure TSharp.SetWeight(Weight : Double);&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;FWeight := Weight;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;procedure TSharp.Display();&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;{Self.ClassName获取当前类名}&lt;/p&gt;
&lt;p&gt;Writeln('Im ', Self.ClassName, ' , my weight is ', FWeight);&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;{空方法，我不明白虚方法为什么还需要在基类实现…}&lt;/p&gt;
&lt;p&gt;procedure TSharp.Draw();&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;end.&lt;/p&gt;
&lt;h2&gt;2.类的继承和多态&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;unit&lt;/span&gt; &lt;span class="n"&gt;UCircle&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Circle&lt;/span&gt;&lt;span class="err"&gt;类模块&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;interface&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;uses&lt;/p&gt;
&lt;p&gt;USharp;&lt;/p&gt;
&lt;p&gt;type&lt;/p&gt;
&lt;p&gt;TCircle = class(TSharp)&lt;/p&gt;
&lt;p&gt;private&lt;/p&gt;
&lt;p&gt;FR : Double;&lt;/p&gt;
&lt;p&gt;procedure SetR (R : Double);&lt;/p&gt;
&lt;p&gt;public&lt;/p&gt;
&lt;p&gt;property R : Double read FR write SetR;&lt;/p&gt;
&lt;p&gt;{重载父类Display方法}&lt;/p&gt;
&lt;p&gt;procedure Display();&lt;/p&gt;
&lt;p&gt;{重写父类Draw虚方法，关键词override}&lt;/p&gt;
&lt;p&gt;procedure Draw(); override;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;implementation&lt;/p&gt;
&lt;p&gt;procedure TCircle.SetR(R : Double);&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;FR := R;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;procedure TCircle.Display();&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;Writeln('Im ', Self.ClassName, ' , I am in TCircle.');&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;procedure TCircle.Draw();&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;Writeln('Draw a Circle.');&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;end.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;unit&lt;/span&gt; &lt;span class="n"&gt;USquare&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;interface&lt;/p&gt;
&lt;p&gt;uses&lt;/p&gt;
&lt;p&gt;USharp;&lt;/p&gt;
&lt;p&gt;type&lt;/p&gt;
&lt;p&gt;{定义类TSharp}&lt;/p&gt;
&lt;p&gt;TSquare = class(TSharp)&lt;/p&gt;
&lt;p&gt;private&lt;/p&gt;
&lt;p&gt;FX : Double;&lt;/p&gt;
&lt;p&gt;FY : Double;&lt;/p&gt;
&lt;p&gt;procedure SetX(X : Double);&lt;/p&gt;
&lt;p&gt;procedure SetY(Y : Double);&lt;/p&gt;
&lt;p&gt;public&lt;/p&gt;
&lt;p&gt;{定义属性Weight}&lt;/p&gt;
&lt;p&gt;property X : Double read FX write SetX;&lt;/p&gt;
&lt;p&gt;property Y : Double read FY write SetY;&lt;/p&gt;
&lt;p&gt;procedure Display();&lt;/p&gt;
&lt;p&gt;{重写父类Draw虚方法，关键词override}&lt;/p&gt;
&lt;p&gt;procedure Draw(); override;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;{实现}&lt;/p&gt;
&lt;p&gt;implementation&lt;/p&gt;
&lt;p&gt;procedure TSquare.SetX(X : Double);&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;FX := X;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;procedure TSquare.SetY(Y : Double);&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;FY := Y;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;procedure TSquare.Display();&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;{Self.ClassName获取当前类名}&lt;/p&gt;
&lt;p&gt;Writeln('Im ', Self.ClassName, ' , my x is ', X, ', y is ', Y);&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;procedure TSquare.Draw();&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;Writeln('Draw a Square.');&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;end.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;program&lt;/span&gt; &lt;span class="n"&gt;P2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;使用类继承和多&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pas&lt;/span&gt;&lt;span class="err"&gt;文件&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{$APPTYPE CONSOLE}&lt;/p&gt;
&lt;p&gt;uses&lt;/p&gt;
&lt;p&gt;SysUtils,&lt;/p&gt;
&lt;p&gt;USharp in 'USharp.pas',&lt;/p&gt;
&lt;p&gt;UCircle in 'UCircle.pas',&lt;/p&gt;
&lt;p&gt;USquare in 'USquare.pas';&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;Sharp : TSharp;&lt;/p&gt;
&lt;p&gt;Circle : TCircle;&lt;/p&gt;
&lt;p&gt;Square : TSquare;&lt;/p&gt;
&lt;p&gt;{用来进行多态的TSharp}&lt;/p&gt;
&lt;p&gt;SharpVirtual : TSharp;&lt;/p&gt;
&lt;p&gt;{用来进行类型转换的TSquare}&lt;/p&gt;
&lt;p&gt;SquareForAs : TSquare;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;Sharp := TSharp.Create();&lt;/p&gt;
&lt;p&gt;Sharp.Weight := 1.3;&lt;/p&gt;
&lt;p&gt;Sharp.Display();&lt;/p&gt;
&lt;p&gt;Circle := TCircle.Create();&lt;/p&gt;
&lt;p&gt;Circle.Weight := 2.2;&lt;/p&gt;
&lt;p&gt;Circle.R := 1.2;&lt;/p&gt;
&lt;p&gt;Circle.Display();&lt;/p&gt;
&lt;p&gt;Square := TSquare.Create();&lt;/p&gt;
&lt;p&gt;Square.Weight := 4.5;&lt;/p&gt;
&lt;p&gt;Square.X := 2;&lt;/p&gt;
&lt;p&gt;Square.Y := 3;&lt;/p&gt;
&lt;p&gt;Square.Display();&lt;/p&gt;
&lt;p&gt;{将变量分别指向TCicle和TSquare，运行Draw实现多态}&lt;/p&gt;
&lt;p&gt;SharpVirtual := TCircle.Create();&lt;/p&gt;
&lt;p&gt;SharpVirtual.Draw();&lt;/p&gt;
&lt;p&gt;SharpVirtual := TSquare.Create();&lt;/p&gt;
&lt;p&gt;SharpVirtual.Draw();&lt;/p&gt;
&lt;p&gt;{is操作符}&lt;/p&gt;
&lt;p&gt;Writeln(Circle is TCircle);&lt;/p&gt;
&lt;p&gt;Writeln(SharpVirtual is TCircle);&lt;/p&gt;
&lt;p&gt;Writeln(SharpVirtual is TSquare);&lt;/p&gt;
&lt;p&gt;{as类转换操作符}&lt;/p&gt;
&lt;p&gt;SquareForAs := SharpVirtual as TSquare;&lt;/p&gt;
&lt;p&gt;SquareForAs.Draw;&lt;/p&gt;
&lt;p&gt;Readln;&lt;/p&gt;
&lt;p&gt;end.&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;本来准备入手&lt;strong&gt;VCL&lt;/strong&gt;，结果事情太多，下午党员会议，晚上我又提前1个月过生日请朋友吃饭唱歌，耽误了```&lt;/p&gt;</summary><category term=""></category></entry><entry><title>Delphi学习笔记05</title><link href="/2009/12/delphi-study-notes-05/" rel="alternate"></link><updated>2009-12-01T00:00:00+08:00</updated><author><name>alswl</name></author><id>tag:,2009-12-01:2009/12/delphi-study-notes-05/</id><summary type="html">&lt;p&gt;今天是第五天了，我对自己的学习速度很不满意，还是处在半懵懂状态。语法还要经过大脑才能想出来，一点不顺手。&lt;/p&gt;
&lt;p&gt;VCL控件使用了几个简单的，&lt;strong&gt;BDE数据库&lt;/strong&gt;和&lt;strong&gt;ADO数据库&lt;/strong&gt;这一块还没有涉及，&lt;strong&gt;网络编程&lt;/strong&gt;也没涉及到。&lt;/p&gt;
&lt;p&gt;这几天事情很烦，18号的课程设计赶不上了，我之前又是做的"&lt;a href="http://log4d.com/tag/pylexchat"&gt;&lt;strong&gt;PylexChat&lt;/strong&gt;&lt;/a&gt;"聊
天系统这么有挑战性的题目。唉，真开始后悔了，老师那里也不好说，郁闷。还得等我组员回来讨论一下，这周就得答辩了。当时老师突然说："那你不是在学Delphi么，
就用Delphi写一个吧"，我狂晕，学一门语言又不是吃菜，总得有个进度吧~&lt;/p&gt;
&lt;p&gt;昨天请同学吃饭，我把我生日提前一个月过，请一帮兔崽子吃饭唱歌，闹到11点多才回来，所以昨天的总结今天早晨才更新。&lt;/p&gt;
&lt;p&gt;ps:我之前使用的Delphi7版本是绿色精简完美版，在&lt;strong&gt;插入&lt;code&gt;AboutBox&lt;/code&gt;&lt;/strong&gt;和&lt;strong&gt;跟踪源码&lt;/strong&gt;（在某个VCL类名如TForm上Ctrl+单击）时
候出现找不到".pas"的错误，我之后重新安装了188MB的安装版，错误消失了，所以推荐大家使用安装版。&lt;/p&gt;
&lt;p&gt;以上废话结束，下面正文。&lt;/p&gt;
&lt;h2&gt;1.同构数的Delphi实现&lt;/h2&gt;
&lt;p&gt;这道题目是在一个PPT上看到的,题目如下："&lt;strong&gt;如果一个数刚好出现在其平方的右边，如5的平方为25，6的平方为36，这样的数我们称为同构数，请编程找出1～9
999的全部同构数&lt;/strong&gt;"。题目对我的难点在于类型的转换和&lt;code&gt;Math&lt;/code&gt;函数的熟悉。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;program&lt;/span&gt; &lt;span class="n"&gt;P1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;如果一个数刚好出现在其平方的右边，如&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="err"&gt;的平方&lt;/span&gt;
&lt;span class="err"&gt;为&lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="err"&gt;的平方为&lt;/span&gt;&lt;span class="mi"&gt;36&lt;/span&gt;&lt;span class="err"&gt;，这样的数我们称为同构数，&lt;/span&gt;
&lt;span class="err"&gt;请编程找出&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;～&lt;/span&gt;&lt;span class="mi"&gt;9999&lt;/span&gt;&lt;span class="err"&gt;的全部同构数&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{$APPTYPE CONSOLE}&lt;/p&gt;
&lt;p&gt;uses&lt;/p&gt;
&lt;p&gt;SysUtils, Math;&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;{定义这么多变量是为了容易调试}&lt;/p&gt;
&lt;p&gt;a, b, c, t : Double;&lt;/p&gt;
&lt;p&gt;i : Integer;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;for i := 1 to 9999 do&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;a := i * i;&lt;/p&gt;
&lt;p&gt;{Trunc取整}&lt;/p&gt;
&lt;p&gt;t := Trunc(Log10(i)) + 1;&lt;/p&gt;
&lt;p&gt;{Power x^y}&lt;/p&gt;
&lt;p&gt;b := Power(10, t);&lt;/p&gt;
&lt;p&gt;c := Trunc(a) mod Trunc(b);&lt;/p&gt;
&lt;p&gt;if i = c then&lt;/p&gt;
&lt;p&gt;Write(i, ' ');&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;Readln;&lt;/p&gt;
&lt;p&gt;end.&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;注意里面的几个&lt;code&gt;Math&lt;/code&gt;方法，这些函数的熟悉和累计不是一朝一夕能够完成的，我现在正在总结一个"Dlphi资料小汇总"
，总结好了之后再发布。&lt;/p&gt;
&lt;h2&gt;2.仿Window记事本的编辑器&lt;/h2&gt;
&lt;p&gt;本来是有一道例题实现Windows计算器，我感觉实现记事本更能接触各种控件，于是花了2个小时摸索这块内容。&lt;/p&gt;
&lt;p&gt;代码我就贴一个核心区的，没写注释。如果学过C#，应该很容易看懂，都出自Heljsberg，Application的结构很类似。（等我空下来，好好写一篇文章了
解一下Heljsberg）&lt;/p&gt;
&lt;p&gt;实现了打开、保存、字体功能，没有另存为和换行、查找功能。- -#（这是记事本？）&lt;/p&gt;
&lt;p&gt;一个小亮点就是如果文章修改了会有(*)标记，呵呵。&lt;/p&gt;
&lt;p&gt;上个小图&lt;/p&gt;
&lt;p&gt;&lt;a href="http
://upload-log4d.qiniudn.com/2009/12/delphi_editor.jpg"&gt;&lt;img alt="" src="http://upload-log4d.qiniudn.com/2009/12/delphi_editor.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;procedure&lt;/span&gt; &lt;span class="n"&gt;TForm1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;O1Click&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Sender&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;TObject&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;begin&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;odOpenFile&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Execute&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt;
  &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="n"&gt;FFileName&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;odOpenFile&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FileName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;mmContent&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Lines&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;LoadFromFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;odOpenFile&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FileName&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Caption&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;FFileName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FIsEdited&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;False&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;procedure TForm1.S1Click(Sender: TObject);&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;if FFileName &amp;lt;&amp;gt; '' then&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;mmContent.Lines.SaveToFile(FFileName);&lt;/p&gt;
&lt;p&gt;FFileName := odOpenFile.FileName;&lt;/p&gt;
&lt;p&gt;Self.Caption := FFileName;&lt;/p&gt;
&lt;p&gt;Self.FIsEdited := False;&lt;/p&gt;
&lt;p&gt;end&lt;/p&gt;
&lt;p&gt;else&lt;/p&gt;
&lt;p&gt;if sdSaveFile.Execute then&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;FFileName := sdSaveFile.FileName;&lt;/p&gt;
&lt;p&gt;mmContent.Lines.SaveToFile(FFileName);&lt;/p&gt;
&lt;p&gt;Self.Caption := FFileName;&lt;/p&gt;
&lt;p&gt;Self.FIsEdited := False;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;procedure TForm1.T1Click(Sender: TObject);&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;fdFont.Font := mmContent.Font;&lt;/p&gt;
&lt;p&gt;if fdFont.Execute then&lt;/p&gt;
&lt;p&gt;mmContent.Font := fdFont.Font;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;procedure TForm1.X1Click(Sender: TObject);&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;Form1.Close();&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;procedure TForm1.A1Click(Sender: TObject);&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;abAbout.Show();&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;procedure TForm1.FormCreate(Sender: TObject);&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;FFileName := '';&lt;/p&gt;
&lt;p&gt;FIsEdited := False;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;procedure TForm1.mmContentChange(Sender: TObject);&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;if Self.FIsEdited = false then&lt;/p&gt;
&lt;p&gt;Self.Caption := Self.Caption + ' (*)';&lt;/p&gt;
&lt;p&gt;Self.FIsEdited := True;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;procedure TForm1.FormCloseQuery(Sender: TObject; var CanClose: Boolean);&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;IsExit : Integer;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;if FIsEdited = True then&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;isExit := MessageDlg('正文已修改，是否保存？', mtConfirmation,&lt;/p&gt;
&lt;p&gt;[mbYes, mbNo, mbCancel], 0);&lt;/p&gt;
&lt;p&gt;case IsExit of&lt;/p&gt;
&lt;p&gt;mrYes : Self.S1Click(Sender);&lt;/p&gt;
&lt;p&gt;mrCancel : CanClose := False;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;end.&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;我把这个小程序打包，如果对源码有兴趣，可以看一下。&lt;/p&gt;
&lt;p&gt;点击这里下载&lt;a href="http://upload-
log4d.qiniudn.com/2009/12/delphi_editor.zip"&gt;delphi_editor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;学校暖气坏了，我得跑出去洗澡，今天就先到这里吧。&lt;/p&gt;</summary><category term=""></category></entry><entry><title>Delphi源程序格式书写规范【转】</title><link href="/2009/11/delphi-source-code-written-in-standard-format-switch/" rel="alternate"></link><updated>2009-11-30T00:00:00+08:00</updated><author><name>alswl</name></author><id>tag:,2009-11-30:2009/11/delphi-source-code-written-in-standard-format-switch/</id><summary type="html">&lt;p&gt;话说我不喜欢转帖，可是看到实在好的东西又想留下来，真矛盾。为此，我凡是所有转的帖子都在标题上注明转帖，大家如果不感兴趣，可以直接略过。&lt;/p&gt;
&lt;p&gt;下面的这篇文章出处：&lt;a href="http://tieba.baidu.com/f?kz=84767888"&gt;百度_delphi吧_Delphi 源程序格式书写规范&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文章很长，我看了很长时间，好的代码风格将是一个程序员终身受益。文中的一些关于Tab/空格问题我完全同意，不过在个别地方，比如变量名定义上持中立意见，我觉得每
个人、每个公司的编码风格还是会有出入的。总体来说，这篇文章作为参考是很不错的。&lt;/p&gt;
&lt;p&gt;我整理了半小时，将原来的一个p分成3级h2/h3/p，呃，方便阅读吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;*&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;原文送上&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;*&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;感谢&amp;amp;nbsp_place_holder;tianhaiyise&amp;amp;nbsp_place_holder;提供的来自&amp;amp;nbsp_place_holder;&lt;a href="http://www.delphiforums.com/"&gt;ht
tp://www.delphiforums.com/&lt;/a&gt;&amp;amp;nbsp_place_holder;的译
本&lt;/p&gt;
&lt;h2&gt;1.规范简介&lt;/h2&gt;
&lt;p&gt;本规范主要规定Delphi源程序在书写过程中所应遵循的规则及注意事项。编写该规范的目的是使公司软件开发人员的源代码书写习惯保持一致。这样做可以使每一个组员都
可以理解其它组员的代码，以便于源代码的二次开发记忆系统的维护。&lt;/p&gt;
&lt;h2&gt;2.一般格式规范&lt;/h2&gt;
&lt;h3&gt;2.1缩进&lt;/h3&gt;
&lt;p&gt;缩进就是在当源程序的级改变时为增加可读性而露出的两个空格。缩进的规则为每一级缩进两个空格。不准许使用Tab。因为Tab会因为用户所作的设 置不同而产生不同的
效果。当遇到begin&amp;amp;nbsp_place_holder;或进入判断、循环、异常处理、with语句、记录类型声明、类声明等的时侯增加一级，&amp;amp;nbsp_pl
ace_holder;当遇到end或退出判 断、循环、异常处理、with语句、记录类型声明、类声明等的时侯减少一级。例如：&lt;/p&gt;
&lt;p&gt;if&amp;amp;nbsp_place_holder;TmpInt&amp;amp;nbsp_place_holder;&amp;lt;&amp;gt;&amp;amp;nbsp_place_holder;100&amp;amp;nbsp_pl
ace_holder;then&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;TmpInt&amp;amp;nbsp_place_holder;:=&amp;amp;nbsp_place_h
older;100;&lt;/p&gt;
&lt;h3&gt;2.2&amp;amp;nbsp_place_holder;Begin..End&lt;/h3&gt;
&lt;p&gt;begin语句和end语句在源程序中要独占一行，例如:&lt;/p&gt;
&lt;p&gt;for&amp;amp;nbsp_place_holder;I&amp;amp;nbsp_place_holder;:=&amp;amp;nbsp_place_holder;0&amp;amp;nbsp_place_ho
lder;to&amp;amp;nbsp_place_holder;10&amp;amp;nbsp_place_holder;do&amp;amp;nbsp_place_holder;begin&amp;amp;nbsp
_place_holder;//不正确的用法&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;for&amp;amp;nbsp_place_holder;I&amp;amp;nbsp_place_holder;:=&amp;amp;nbsp_place_holder;0&amp;amp;nbsp_place_ho
lder;to&amp;amp;nbsp_place_holder;10&amp;amp;nbsp_place_holder;do&amp;amp;nbsp_place_holder;&amp;amp;nbsp_plac
e_holder;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_
holder;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;//正确的用法&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;h3&gt;2.3空格&lt;/h3&gt;
&lt;p&gt;在操作符及逻辑判断符号的两端添加空格，例如：I&amp;amp;nbsp_place_holder;:=&amp;amp;nbsp_place_holder;I&amp;amp;nbsp_place_ho
lder;+&amp;amp;nbsp_place_holder;1;，a&amp;amp;nbsp_place_holder;and&amp;amp;nbsp_place_holder;b&amp;amp;nbsp_p
lace_holder;等，但添加括号时不需要空格。例如：if&amp;amp;nbsp_place_holder;(&amp;amp;nbsp_place_holder;a&amp;amp;nbsp_p
lace_holder;&amp;gt;&amp;amp;nbsp_place_holder;b&amp;amp;nbsp_place_holder;)&amp;amp;nbsp_place_holder;then&amp;amp;n
bsp_place_holder;&amp;amp;nbsp_place_holder;//错误的用法&lt;/p&gt;
&lt;p&gt;If&amp;amp;nbsp_place_holder;(a&amp;amp;nbsp_place_holder;&amp;gt;&amp;amp;nbsp_place_holder;b)&amp;amp;nbsp_place_ho
lder;then&amp;amp;nbsp_place_holder;//正确的用法&lt;/p&gt;
&lt;p&gt;又例如：procedure&amp;amp;nbsp_place_holder;Test(Param1:&amp;amp;nbsp_place_holder;integer;&amp;amp;nbsp_p
lace_holder;Param3:&amp;amp;nbsp_place_holder;string);&lt;/p&gt;
&lt;h2&gt;3.&amp;amp;nbsp_place_holder;Object&amp;amp;nbsp_place_holder;Pascal语法书写格式规范&lt;/h2&gt;
&lt;h3&gt;3.1保留字&lt;/h3&gt;
&lt;p&gt;Object&amp;amp;nbsp_place_holder;Pascal&amp;amp;nbsp_place_holder;语言的保留字或关键词应全部使用小写字母。&lt;/p&gt;
&lt;h3&gt;3.2过程和函数&lt;/h3&gt;
&lt;h4&gt;3.2.1命名及格式&lt;/h4&gt;
&lt;p&gt;过程和函数的名称应全部使用有意义的单词组成，并且所有单词的第一个字母应该使用大写字母。例如：&lt;/p&gt;
&lt;p&gt;procedure&amp;amp;nbsp_place_holder;formatharddisk;//不正确的命名&lt;/p&gt;
&lt;p&gt;procedure&amp;amp;nbsp_place_holder;FormatHardDisk;//正确的命名&lt;/p&gt;
&lt;p&gt;设置变量内容的过程和函数，应使用Set作为前缀，例如：&lt;/p&gt;
&lt;p&gt;procedure&amp;amp;nbsp_place_holder;SetUserName;&lt;/p&gt;
&lt;p&gt;读取变量内容的过程和函数，应使用Get作为前缀，例如：&lt;/p&gt;
&lt;p&gt;function&amp;amp;nbsp_place_holder;GetUserName:&amp;amp;nbsp_place_holder;string;&lt;/p&gt;
&lt;h4&gt;3.2.2&amp;amp;nbsp_place_holder;过程和函数的参数&lt;/h4&gt;
&lt;p&gt;3.2.2.1命名&lt;/p&gt;
&lt;p&gt;统一类型的参数写在同一句中:&lt;/p&gt;
&lt;p&gt;procedure&amp;amp;nbsp_place_holder;Foo(Param1,&amp;amp;nbsp_place_holder;Param2,&amp;amp;nbsp_place_h
older;Param3:&amp;amp;nbsp_place_holder;Integer;&amp;amp;nbsp_place_holder;Param4:&amp;amp;nbsp_place_
holder;string);&lt;/p&gt;
&lt;p&gt;3.2.2.2命名&lt;/p&gt;
&lt;p&gt;所有参数必须是有意义的；并且当参数名称和其它属性名称重了的时候，加一个前缀'A',&amp;amp;nbsp_place_holder;例如：&lt;/p&gt;
&lt;p&gt;procedure&amp;amp;nbsp_place_holder;SomeProc(AUserName:&amp;amp;nbsp_place_holder;string;&amp;amp;nbsp
_place_holder;AUserAge:&amp;amp;nbsp_place_holder;integer);&lt;/p&gt;
&lt;p&gt;3.2.2.3命名冲突&lt;/p&gt;
&lt;p&gt;当使用的两个unit中包括一个重名的函数或过程时,&amp;amp;nbsp_place_holder;那幺当你引用这一函数或过程时，将执行在use&amp;amp;nbsp_place_
holder;子句中后声明的那个unit中的函数或过程。为了避免这种'uses-clause-
dependent'需要在引用函数或过程时，写完整函数或过程的出处。例如：&lt;/p&gt;
&lt;p&gt;SysUtils.FindClose(SR);&lt;/p&gt;
&lt;p&gt;Windows.FindClose(Handle);&lt;/p&gt;
&lt;h3&gt;3.3&amp;amp;nbsp_place_holder;变量&lt;/h3&gt;
&lt;h4&gt;3.3.1&amp;amp;nbsp_place_holder;变量命名及格式&lt;/h4&gt;
&lt;p&gt;首先所有变量必须起有意义的名字，使其它组员可以很容易读懂变量所代表的意义，变量命名可以采用同义的英文命名，可使用几个英文单词，但每一单词的首字母必须大写。例
如：&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;WriteFormat:：string；&lt;/p&gt;
&lt;p&gt;同时对于一些特定类型可采用一定的简写如下：&lt;/p&gt;
&lt;p&gt;指针类型&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;P&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&lt;/p&gt;
&lt;p&gt;纪录类型&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;Rec&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&lt;/p&gt;
&lt;p&gt;数组类型&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;Arr&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&lt;/p&gt;
&lt;p&gt;类&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;Class&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&lt;/p&gt;
&lt;p&gt;循环控制变量通常使用单一的字符如：i,&amp;amp;nbsp_place_holder;j,&amp;amp;nbsp_place_holder;或&amp;amp;nbsp_place_holder
;k。&amp;amp;nbsp_place_holder;另外使用一个有意义的名字例如：UserIndex&amp;amp;nbsp_place_holder;，也是准许的。&lt;/p&gt;
&lt;h4&gt;3.3.2&amp;amp;nbsp_place_holder;局部变量&lt;/h4&gt;
&lt;p&gt;在过程中使用局部变量遵循所有其它变量的命名规则。&lt;/p&gt;
&lt;h4&gt;3.3.3&amp;amp;nbsp_place_holder;全局变量&lt;/h4&gt;
&lt;p&gt;尽量不使用全局变量，如必须使用全局变量则必须加前缀'g'，同时应在变量名称中体现变量的类型。例如：&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;gprecUserCount:&amp;amp;nbsp_place_holder;point;
//名称为UserCount的全局变量,其类型为指向一结构的指针&lt;/p&gt;
&lt;p&gt;但是在模块内部可以使用全局变量。所有模块内全局变量必须用'F'为前缀。如果几个模块之间需要进行资料交换，则需要通过声明属性的方法来实现。例如：&lt;/p&gt;
&lt;p&gt;type&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;TFormOverdraftReturn&amp;amp;nbsp_place_holder;=
&amp;amp;nbsp_place_holder;class(TForm)&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;private&lt;/p&gt;
&lt;p&gt;{&amp;amp;nbsp_place_holder;Private&amp;amp;nbsp_place_holder;declarations&amp;amp;nbsp_place_holder;}&lt;/p&gt;
&lt;p&gt;FuserName:&amp;amp;nbsp_place_holder;string;&lt;/p&gt;
&lt;p&gt;FuserCount:&amp;amp;nbsp_place_holder;Integer;&lt;/p&gt;
&lt;p&gt;Procedure&amp;amp;nbsp_place_holder;SetUserName(Value:&amp;amp;nbsp_place_holder;string);&lt;/p&gt;
&lt;p&gt;Function&amp;amp;nbsp_place_holder;GetUserName:&amp;amp;nbsp_place_holder;string;&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;public&lt;/p&gt;
&lt;p&gt;{&amp;amp;nbsp_place_holder;Public&amp;amp;nbsp_place_holder;declarations&amp;amp;nbsp_place_holder;}&lt;/p&gt;
&lt;p&gt;property&amp;amp;nbsp_place_holder;UserName:&amp;amp;nbsp_place_holder;string&amp;amp;nbsp_place_holde
r;read&amp;amp;nbsp_place_holder;GetUserName&amp;amp;nbsp_place_holder;write&amp;amp;nbsp_place_holder
;SetUserName;&lt;/p&gt;
&lt;p&gt;property&amp;amp;nbsp_place_holder;UserCount:&amp;amp;nbsp_place_holder;Integer&amp;amp;nbsp_place_hol
der;read&amp;amp;nbsp_place_holder;FuserCount&amp;amp;nbsp_place_holder;write&amp;amp;nbsp_place_holde
r;FuserCount;&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;end;&lt;/p&gt;
&lt;h3&gt;3.4类型&lt;/h3&gt;
&lt;h4&gt;3.4.1&amp;amp;nbsp_place_holder;大小写协议&lt;/h4&gt;
&lt;p&gt;保留字的类型名称必须全部小写。Win32&amp;amp;nbsp_place_holder;API&amp;amp;nbsp_place_holder;的类型通常全部大写，对于其它类型则
首字母大写，其余字母小写，例如：&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;MyString:&amp;amp;nbsp_place_holder;string;&amp;amp;nbsp
_place_holder;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;//&amp;amp;nbsp_place_holder;reser
ved&amp;amp;nbsp_place_holder;word&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;WindowHandle:&amp;amp;nbsp_place_holder;HWND;&amp;amp;nb
sp_place_holder;//&amp;amp;nbsp_place_holder;Win32&amp;amp;nbsp_place_holder;API&amp;amp;nbsp_place_ho
lder;type&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;I:&amp;amp;nbsp_place_holder;Integer;&amp;amp;nbsp_place
_holder;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;//&amp;amp;nbsp_place
_holder;type&amp;amp;nbsp_place_holder;identifier&amp;amp;nbsp_place_holder;introduced&amp;amp;nbsp_pl
ace_holder;in&amp;amp;nbsp_place_holder;System&amp;amp;nbsp_place_holder;unit&lt;/p&gt;
&lt;h4&gt;3.4.2&amp;amp;nbsp_place_holder;浮点类型&lt;/h4&gt;
&lt;p&gt;尽量不使用&amp;amp;nbsp_place_holder;Real&amp;amp;nbsp_place_holder;类型，他只是为了和旧的Pascal代码兼容，尽量使用Doubl
e&amp;amp;nbsp_place_holder;类型。Double&amp;amp;nbsp_place_holder;类型是对处理器和数据总线做过 最优化的并且是IEEE定义的标
准数据结构。当数值超出Double的范围时，使用Extended&amp;amp;nbsp_place_holder;。但Extended不被Jave支持。但使用其它
语言编写的DLL时可能会使用Single&amp;amp;nbsp_place_holder;类型。&lt;/p&gt;
&lt;h4&gt;3.4.3&amp;amp;nbsp_place_holder;枚举类型&lt;/h4&gt;
&lt;p&gt;枚举类型的名字必须有意义并且类型的名字之前要加前缀'T'。枚举类型的内容的名字必须包含枚举类型名称的简写，例如：&lt;/p&gt;
&lt;p&gt;TSongType&amp;amp;nbsp_place_holder;=&amp;amp;nbsp_place_holder;(stRock,&amp;amp;nbsp_place_holder;stC
lassical,&amp;amp;nbsp_place_holder;stCountry,&amp;amp;nbsp_place_holder;stAlternative,&amp;amp;nbsp_p
lace_holder;stHeavyMetal,&amp;amp;nbsp_place_holder;stRB);&lt;/p&gt;
&lt;h4&gt;3.4.4&amp;amp;nbsp_place_holder;数组类型&lt;/h4&gt;
&lt;p&gt;数组类型的名字必须有意义并且类型的名字之前要加前缀'T'。如果声明一个指向数组类型的指针必须在该类型的名字之前加前缀'P'，例如：&lt;/p&gt;
&lt;p&gt;type&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;PCycleArray&amp;amp;nbsp_place_holder;=&amp;amp;nbsp_pla
ce_holder;^TCycleArray;&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;TCycleArray&amp;amp;nbsp_place_holder;=&amp;amp;nbsp_pla
ce_holder;array[1..100]&amp;amp;nbsp_place_holder;of&amp;amp;nbsp_place_holder;integer;&lt;/p&gt;
&lt;h5&gt;3.4.5记录类型&lt;/h5&gt;
&lt;p&gt;记录类型的名字必须有意义并且类型的名字之前要加前缀'T'。如果声明一个指向数组类型的指针必须在该类型的名字之前加前缀'P'，例如：&lt;/p&gt;
&lt;p&gt;type&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;PEmployee&amp;amp;nbsp_place_holder;=&amp;amp;nbsp_place
_holder;^TEmployee;&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;TEmployee&amp;amp;nbsp_place_holder;=&amp;amp;nbsp_place
_holder;record&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;Em
ployeeName:&amp;amp;nbsp_place_holder;string&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;Em
ployeeRate:&amp;amp;nbsp_place_holder;Double;&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;end;&lt;/p&gt;
&lt;h3&gt;3.5类&lt;/h3&gt;
&lt;h5&gt;3.5.1&amp;amp;nbsp_place_holder;命名及格式&lt;/h5&gt;
&lt;p&gt;类的名字必须有意义并且类型的名字之前要加前缀'T'。例如：&lt;/p&gt;
&lt;p&gt;type&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;TCustomer&amp;amp;nbsp_place_holder;=&amp;amp;nbsp_place_holder;class(TObje
ct)&lt;/p&gt;
&lt;p&gt;类实例的名字通常是去掉'T'的类的名字。例如：&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;Customer:&amp;amp;nbsp_place_holder;TCustomer;&lt;/p&gt;
&lt;h5&gt;3.5.2&amp;amp;nbsp_place_holder;类中的变量&lt;/h5&gt;
&lt;p&gt;3.5.2.1命名及格式&lt;/p&gt;
&lt;p&gt;类的名字必须有意义并且类型的名字之前要加前缀'F'。所有的变量必须是四有的。如果需要从外部访问此变量则需要声明一属性&lt;/p&gt;
&lt;h4&gt;3.5.3&amp;amp;nbsp_place_holder;方法&lt;/h4&gt;
&lt;p&gt;3.5.3.1命名及格式&lt;/p&gt;
&lt;p&gt;同函数和过程的命名及格式。&lt;/p&gt;
&lt;p&gt;3.5.3.2&amp;amp;nbsp_place_holder;属性访问方法&lt;/p&gt;
&lt;p&gt;所有的属性访问方法必须出现在private&amp;amp;nbsp_place_holder;或&amp;amp;nbsp_place_holder;protected&amp;amp;nbsp_pla
ce_holder;中。属性访问方法的命名同函数和过程的命名另外读方法 (reader&amp;amp;nbsp_place_holder;method)必须使用前缀'Ge
t'.&amp;amp;nbsp_place_holder;写方法(writer&amp;amp;nbsp_place_holder;method)必须使用前缀'Set'。写方法的参数必须
命名为 'Value'，其类型同所要写的属性相一致。例如：&lt;/p&gt;
&lt;p&gt;TSomeClass&amp;amp;nbsp_place_holder;=&amp;amp;nbsp_place_holder;class(TObject)&lt;/p&gt;
&lt;p&gt;private&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;FSomeField:&amp;amp;nbsp_place_holder;Integer;&lt;/p&gt;
&lt;p&gt;protected&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;function&amp;amp;nbsp_place_holder;GetSomeField:&amp;amp;nbsp_place_holder;
Integer;&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;procedure&amp;amp;nbsp_place_holder;SetSomeField(&amp;amp;nbsp_place_holder
;Value:&amp;amp;nbsp_place_holder;Integer);&lt;/p&gt;
&lt;p&gt;public&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;property&amp;amp;nbsp_place_holder;SomeField:&amp;amp;nbsp_place_holder;Int
eger&amp;amp;nbsp_place_holder;read&amp;amp;nbsp_place_holder;GetSomeField&amp;amp;nbsp_place_holder;w
rite&amp;amp;nbsp_place_holder;SetSomeField;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;h3&gt;3.6属性&lt;/h3&gt;
&lt;h4&gt;3.6.1&amp;amp;nbsp_place_holder;命名及格式&lt;/h4&gt;
&lt;p&gt;同其用操作的，出去前缀'F'的类的变量的名称相一致&amp;amp;nbsp_place_holder;。&lt;/p&gt;
&lt;h3&gt;3.7文件&lt;/h3&gt;
&lt;h4&gt;3.7.1项目文件&lt;/h4&gt;
&lt;p&gt;3.7.1.1项目目录结构&lt;/p&gt;
&lt;p&gt;程序主目录--Bin（应用程序所在路径）&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;-Db（本地数据库所在路径）&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;-Doc（文档所在路径）&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;-Hlp（帮助文件所在路径）&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;-Backup（备份路径）&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;-Tmp（临时文件路径）&lt;/p&gt;
&lt;p&gt;3.7.1.2命名&lt;/p&gt;
&lt;p&gt;项目文件必须使用一个有意义的名字。例如：&amp;amp;nbsp_place_holder;Delphi中系统信息的项目文件被命名为&amp;amp;nbsp_place_holder;
SysInfo.dpr。&lt;/p&gt;
&lt;h4&gt;3.7.2&amp;amp;nbsp_place_holder;Form&amp;amp;nbsp_place_holder;文件&lt;/h4&gt;
&lt;p&gt;3.7.2.1命名&lt;/p&gt;
&lt;p&gt;同Form的名称相一致：例如：Form的名称为FormMain则Form文件的名称就为FormMain.frm。&lt;/p&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;p&gt;3.7.3&amp;amp;nbsp_place_holder;Data&amp;amp;nbsp_place_holder;Module&amp;amp;nbsp_place_holder;文件&lt;/p&gt;
&lt;p&gt;3.7.3.1命名&lt;/p&gt;
&lt;p&gt;data&amp;amp;nbsp_place_holder;module文件的命名应该有意义，并且使用'DM'作为前缀。例如：&amp;amp;nbsp_place_holder;用户d
ata&amp;amp;nbsp_place_holder;module&amp;amp;nbsp_place_holder;被命名为'DMCustomers.dfm'。&lt;/p&gt;
&lt;h4&gt;3.7.4&amp;amp;nbsp_place_holder;Remote&amp;amp;nbsp_place_holder;Data&amp;amp;nbsp_place_holder;M&lt;/h4&gt;
&lt;p&gt;odule&amp;amp;nbsp_place_holder;文件&lt;/p&gt;
&lt;p&gt;3.7.4.1&amp;amp;nbsp_place_holder;命名&lt;/p&gt;
&lt;p&gt;remote&amp;amp;nbsp_place_holder;data&amp;amp;nbsp_place_holder;module文件的命名应该有意义，并且使用'RDM'作为前缀
。例如：用户remote&amp;amp;nbsp_place_holder;data&amp;amp;nbsp_place_holder;module&amp;amp;nbsp_place_holder
;被命名为'RDMCustomers.dfm'。&lt;/p&gt;
&lt;h4&gt;3.7.5&amp;amp;nbsp_place_holder;Unit文件&lt;/h4&gt;
&lt;p&gt;3.7.5.1普通&amp;amp;nbsp_place_holder;Unit&lt;/p&gt;
&lt;p&gt;3.7.5.1.1&amp;amp;nbsp_place_holder;Unit文件命名&lt;/p&gt;
&lt;p&gt;unit文件的命名应该有意义，并且使用'unit'作为前缀。例如：&amp;amp;nbsp_place_holder;通用unit&amp;amp;nbsp_place_holder;被
命名为'UnitGeneral'。&lt;/p&gt;
&lt;p&gt;3.7.5.2&amp;amp;nbsp_place_holder;Form&amp;amp;nbsp_place_holder;Units&lt;/p&gt;
&lt;p&gt;3.7.5.2.1命名&lt;/p&gt;
&lt;p&gt;Form&amp;amp;nbsp_place_holder;unit&amp;amp;nbsp_place_holder;文件的名字必须和Form的名称保持一致。例如：主窗体叫FormM
ain.pas&amp;amp;nbsp_place_holder;则Form&amp;amp;nbsp_place_holder;Unit文件的名字为：UnitFormMain。&lt;/p&gt;
&lt;p&gt;3.7.5.3&amp;amp;nbsp_place_holder;Data&amp;amp;nbsp_place_holder;Module&amp;amp;nbsp_place_holder;Unit
s&lt;/p&gt;
&lt;p&gt;3.7.5.3.1命名&lt;/p&gt;
&lt;p&gt;Data&amp;amp;nbsp_place_holder;Module&amp;amp;nbsp_place_holder;unit&amp;amp;nbsp_place_holder;文件的名字必须
和Data&amp;amp;nbsp_place_holder;Module的名称保持一致。例如：主Data&amp;amp;nbsp_place_holder;Module叫DMMain
.pas&amp;amp;nbsp_place_holder;则Data&amp;amp;nbsp_place_holder;Module&amp;amp;nbsp_place_holder;Unit文件
的名字为：UnitDMMain。&lt;/p&gt;
&lt;p&gt;3.7.5.4&amp;amp;nbsp_place_holder;文件头&lt;/p&gt;
&lt;p&gt;在所有文件的头部应写上此文件的用途，作者，日期及输入和输出。例如：&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;修改日期：&lt;/p&gt;
&lt;p&gt;作者：&lt;/p&gt;
&lt;p&gt;用途：&lt;/p&gt;
&lt;p&gt;本模块结构组成：&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h4&gt;3.7.6&amp;amp;nbsp_place_holder;Forms和Data&amp;amp;nbsp_place_holder;Modules&amp;amp;nbsp_place_h&lt;/h4&gt;
&lt;p&gt;older;Forms&lt;/p&gt;
&lt;p&gt;3.7.6.1&amp;amp;nbsp_place_holder;Form类&lt;/p&gt;
&lt;p&gt;1.&amp;amp;nbsp_place_holder;Form类命名标准&lt;/p&gt;
&lt;p&gt;Forms类的命名应该有意义，并且使用'TForm'作为前缀。例如：&amp;amp;nbsp_place_holder;About&amp;amp;nbsp_place_holder;F
orm类的名字为:&lt;/p&gt;
&lt;p&gt;TAboutForm&amp;amp;nbsp_place_holder;=&amp;amp;nbsp_place_holder;class(TForm)&lt;/p&gt;
&lt;p&gt;主窗体的名字为&lt;/p&gt;
&lt;p&gt;TMainForm&amp;amp;nbsp_place_holder;=&amp;amp;nbsp_place_holder;class(TForm)&lt;/p&gt;
&lt;p&gt;2.&amp;amp;nbsp_place_holder;Form类实例的命名标准&lt;/p&gt;
&lt;p&gt;Form&amp;amp;nbsp_place_holder;的类实例的名字应同期掉'T'的Form类的名字相一致。例如：&lt;/p&gt;
&lt;p&gt;Type&amp;amp;nbsp_place_holder;Name&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;Instance&amp;amp;nbsp_place_holder;Name&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&lt;/p&gt;
&lt;p&gt;TaboutForm&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;AboutForm&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&lt;/p&gt;
&lt;p&gt;TmainForm&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;MainForm&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&lt;/p&gt;
&lt;p&gt;TCustomerEntryForm&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;CustomerEntryForm&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&lt;/p&gt;
&lt;p&gt;3.7.6.2&amp;amp;nbsp_place_holder;Data&amp;amp;nbsp_place_holder;Modules&amp;amp;nbsp_place_holder;For
m&lt;/p&gt;
&lt;p&gt;3.7.6.2.1.&amp;amp;nbsp_place_holder;Data&amp;amp;nbsp_place_holder;Module&amp;amp;nbsp_place_holder;F
orm&amp;amp;nbsp_place_holder;命名标准&lt;/p&gt;
&lt;p&gt;Data&amp;amp;nbsp_place_holder;Modules&amp;amp;nbsp_place_holder;Forms类的命名应该有意义，并且使用'TDM'作为前缀。
例如：&lt;/p&gt;
&lt;p&gt;TDMCustomer&amp;amp;nbsp_place_holder;=&amp;amp;nbsp_place_holder;class(TDataModule)&lt;/p&gt;
&lt;p&gt;TDMOrders&amp;amp;nbsp_place_holder;=&amp;amp;nbsp_place_holder;class(TDataModule)&lt;/p&gt;
&lt;p&gt;3.7.6.2.2.&amp;amp;nbsp_place_holder;Data&amp;amp;nbsp_place_holder;Module&amp;amp;nbsp_place_holder;实
例命名标准&lt;/p&gt;
&lt;p&gt;Data&amp;amp;nbsp_place_holder;Module&amp;amp;nbsp_place_holder;Form&amp;amp;nbsp_place_holder;的类实例的名字
应同期掉'T'的Data&amp;amp;nbsp_place_holder;Module&amp;amp;nbsp_place_holder;Form类的名字相一致。例如：&lt;/p&gt;
&lt;p&gt;Type&amp;amp;nbsp_place_holder;Name&lt;/p&gt;
&lt;p&gt;Instance&amp;amp;nbsp_place_holder;Name&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&lt;/p&gt;
&lt;p&gt;TCustomerDataModule&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;CustomerDataModule&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&lt;/p&gt;
&lt;p&gt;TordersDataModule&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;OrdersDataModule&lt;/p&gt;
&lt;h3&gt;3.8控件&lt;/h3&gt;
&lt;h4&gt;3.8.1&amp;amp;nbsp_place_holder;控件实例的命名&lt;/h4&gt;
&lt;p&gt;控件的实例应使用去掉'T'该控件类的名称作为前缀，例如：&lt;/p&gt;
&lt;p&gt;输入用户姓名的Tedit的名字为：EditUserName。&lt;/p&gt;
&lt;h4&gt;3.8.2&amp;amp;nbsp_place_holder;控件的简写&lt;/h4&gt;
&lt;p&gt;控件的名称可使用以下简写，但所用简写于控件名称之间药添加'_'：&lt;/p&gt;
&lt;p&gt;3.8.2.1&amp;amp;nbsp_place_holder;Standard&amp;amp;nbsp_place_holder;Tab&lt;/p&gt;
&lt;p&gt;mm&amp;amp;nbsp_place_holder;TMainMenu&lt;/p&gt;
&lt;p&gt;pm&amp;amp;nbsp_place_holder;TPopupMenu&lt;/p&gt;
&lt;p&gt;mmi&amp;amp;nbsp_place_holder;TMainMenuItem&lt;/p&gt;
&lt;p&gt;pmi&amp;amp;nbsp_place_holder;TPopupMenuItem&lt;/p&gt;
&lt;p&gt;lbl&amp;amp;nbsp_place_holder;TLabel&lt;/p&gt;
&lt;p&gt;edt&amp;amp;nbsp_place_holder;TEdit&lt;/p&gt;
&lt;p&gt;mem&amp;amp;nbsp_place_holder;TMemo&lt;/p&gt;
&lt;p&gt;btn&amp;amp;nbsp_place_holder;TButton&lt;/p&gt;
&lt;p&gt;cb&amp;amp;nbsp_place_holder;TCheckBox&lt;/p&gt;
&lt;p&gt;rb&amp;amp;nbsp_place_holder;TRadioButton&lt;/p&gt;
&lt;p&gt;lb&amp;amp;nbsp_place_holder;TListBox&lt;/p&gt;
&lt;p&gt;cb&amp;amp;nbsp_place_holder;TComboBox&lt;/p&gt;
&lt;p&gt;scb&amp;amp;nbsp_place_holder;TScrollBar&lt;/p&gt;
&lt;p&gt;gb&amp;amp;nbsp_place_holder;TGroupBox&lt;/p&gt;
&lt;p&gt;rg&amp;amp;nbsp_place_holder;TRadioGroup&lt;/p&gt;
&lt;p&gt;pnl&amp;amp;nbsp_place_holder;TPanel&lt;/p&gt;
&lt;p&gt;cl&amp;amp;nbsp_place_holder;TCommandList&lt;/p&gt;
&lt;p&gt;3.8.2.2&amp;amp;nbsp_place_holder;Additional&amp;amp;nbsp_place_holder;Tab&lt;/p&gt;
&lt;p&gt;bbtn&amp;amp;nbsp_place_holder;TBitBtn&lt;/p&gt;
&lt;p&gt;sb&amp;amp;nbsp_place_holder;TSpeedButton&lt;/p&gt;
&lt;p&gt;me&amp;amp;nbsp_place_holder;TMaskEdit&lt;/p&gt;
&lt;p&gt;sg&amp;amp;nbsp_place_holder;TStringGrid&lt;/p&gt;
&lt;p&gt;dg&amp;amp;nbsp_place_holder;TDrawGrid&lt;/p&gt;
&lt;p&gt;img&amp;amp;nbsp_place_holder;TImage&lt;/p&gt;
&lt;p&gt;shp&amp;amp;nbsp_place_holder;TShape&lt;/p&gt;
&lt;p&gt;bvl&amp;amp;nbsp_place_holder;TBevel&lt;/p&gt;
&lt;p&gt;sbx&amp;amp;nbsp_place_holder;TScrollBox&lt;/p&gt;
&lt;p&gt;clb&amp;amp;nbsp_place_holder;TCheckListbox&lt;/p&gt;
&lt;p&gt;spl&amp;amp;nbsp_place_holder;TSplitter&lt;/p&gt;
&lt;p&gt;stx&amp;amp;nbsp_place_holder;TStaticText&lt;/p&gt;
&lt;p&gt;cht&amp;amp;nbsp_place_holder;TChart&lt;/p&gt;
&lt;p&gt;3.8.2.3&amp;amp;nbsp_place_holder;Win32&amp;amp;nbsp_place_holder;Tab&lt;/p&gt;
&lt;p&gt;tbc&amp;amp;nbsp_place_holder;TTabControl&lt;/p&gt;
&lt;p&gt;pgc&amp;amp;nbsp_place_holder;TPageControl&lt;/p&gt;
&lt;p&gt;il&amp;amp;nbsp_place_holder;TImageList&lt;/p&gt;
&lt;p&gt;re&amp;amp;nbsp_place_holder;TRichEdit&lt;/p&gt;
&lt;p&gt;tbr&amp;amp;nbsp_place_holder;TTrackBar&lt;/p&gt;
&lt;p&gt;prb&amp;amp;nbsp_place_holder;TProgressBar&lt;/p&gt;
&lt;p&gt;ud&amp;amp;nbsp_place_holder;TUpDown&lt;/p&gt;
&lt;p&gt;hk&amp;amp;nbsp_place_holder;THotKey&lt;/p&gt;
&lt;p&gt;ani&amp;amp;nbsp_place_holder;TAnimate&lt;/p&gt;
&lt;p&gt;dtp&amp;amp;nbsp_place_holder;TDateTimePicker&lt;/p&gt;
&lt;p&gt;tv&amp;amp;nbsp_place_holder;TTreeView&lt;/p&gt;
&lt;p&gt;lv&amp;amp;nbsp_place_holder;TListView&lt;/p&gt;
&lt;p&gt;hdr&amp;amp;nbsp_place_holder;THeaderControl&lt;/p&gt;
&lt;p&gt;stb&amp;amp;nbsp_place_holder;TStatusBar&lt;/p&gt;
&lt;p&gt;tlb&amp;amp;nbsp_place_holder;TToolBar&lt;/p&gt;
&lt;p&gt;clb&amp;amp;nbsp_place_holder;TCoolBar&lt;/p&gt;
&lt;p&gt;3.8.2.4&amp;amp;nbsp_place_holder;System&amp;amp;nbsp_place_holder;Tab&lt;/p&gt;
&lt;p&gt;tm&amp;amp;nbsp_place_holder;TTimer&lt;/p&gt;
&lt;p&gt;pb&amp;amp;nbsp_place_holder;TPaintBox&lt;/p&gt;
&lt;p&gt;mp&amp;amp;nbsp_place_holder;TMediaPlayer&lt;/p&gt;
&lt;p&gt;olec&amp;amp;nbsp_place_holder;TOleContainer&lt;/p&gt;
&lt;p&gt;ddcc&amp;amp;nbsp_place_holder;TDDEClientConv&lt;/p&gt;
&lt;p&gt;ddci&amp;amp;nbsp_place_holder;TDDEClientItem&lt;/p&gt;
&lt;p&gt;ddsc&amp;amp;nbsp_place_holder;TDDEServerConv&lt;/p&gt;
&lt;p&gt;ddsi&amp;amp;nbsp_place_holder;TDDEServerItem&lt;/p&gt;
&lt;p&gt;3.8.2.5&amp;amp;nbsp_place_holder;Internet&amp;amp;nbsp_place_holder;Tab&lt;/p&gt;
&lt;p&gt;csk&amp;amp;nbsp_place_holder;TClientSocket&lt;/p&gt;
&lt;p&gt;ssk&amp;amp;nbsp_place_holder;TServerSocket&lt;/p&gt;
&lt;p&gt;wbd&amp;amp;nbsp_place_holder;TWebDispatcher&lt;/p&gt;
&lt;p&gt;pp&amp;amp;nbsp_place_holder;TPageProducer&lt;/p&gt;
&lt;p&gt;tp&amp;amp;nbsp_place_holder;TQueryTableProducer&lt;/p&gt;
&lt;p&gt;dstp&amp;amp;nbsp_place_holder;TDataSetTableProducer&lt;/p&gt;
&lt;p&gt;nmdt&amp;amp;nbsp_place_holder;TNMDayTime&lt;/p&gt;
&lt;p&gt;nec&amp;amp;nbsp_place_holder;TNMEcho&lt;/p&gt;
&lt;p&gt;nf&amp;amp;nbsp_place_holder;TNMFinger&lt;/p&gt;
&lt;p&gt;nftp&amp;amp;nbsp_place_holder;TNMFtp&lt;/p&gt;
&lt;p&gt;nhttp&amp;amp;nbsp_place_holder;TNMHttp&lt;/p&gt;
&lt;p&gt;nMsg&amp;amp;nbsp_place_holder;TNMMsg&lt;/p&gt;
&lt;p&gt;nmsg&amp;amp;nbsp_place_holder;TNMMSGServ&lt;/p&gt;
&lt;p&gt;nntp&amp;amp;nbsp_place_holder;TNMNNTP&lt;/p&gt;
&lt;p&gt;npop&amp;amp;nbsp_place_holder;TNMPop3&lt;/p&gt;
&lt;p&gt;nuup&amp;amp;nbsp_place_holder;TNMUUProcessor&lt;/p&gt;
&lt;p&gt;smtp&amp;amp;nbsp_place_holder;TNMSMTP&lt;/p&gt;
&lt;p&gt;nst&amp;amp;nbsp_place_holder;TNMStrm&lt;/p&gt;
&lt;p&gt;nsts&amp;amp;nbsp_place_holder;TNMStrmServ&lt;/p&gt;
&lt;p&gt;ntm&amp;amp;nbsp_place_holder;TNMTime&lt;/p&gt;
&lt;p&gt;nudp&amp;amp;nbsp_place_holder;TNMUdp&lt;/p&gt;
&lt;p&gt;psk&amp;amp;nbsp_place_holder;TPowerSock&lt;/p&gt;
&lt;p&gt;ngs&amp;amp;nbsp_place_holder;TNMGeneralServer&lt;/p&gt;
&lt;p&gt;html&amp;amp;nbsp_place_holder;THtml&lt;/p&gt;
&lt;p&gt;url&amp;amp;nbsp_place_holder;TNMUrl&lt;/p&gt;
&lt;p&gt;sml&amp;amp;nbsp_place_holder;TSimpleMail&lt;/p&gt;
&lt;p&gt;3.8.2.6&amp;amp;nbsp_place_holder;Data&amp;amp;nbsp_place_holder;Access&amp;amp;nbsp_place_holder;Tab&lt;/p&gt;
&lt;p&gt;ds&amp;amp;nbsp_place_holder;TDataSource&lt;/p&gt;
&lt;p&gt;tbl&amp;amp;nbsp_place_holder;TTable&lt;/p&gt;
&lt;p&gt;qry&amp;amp;nbsp_place_holder;TQuery&lt;/p&gt;
&lt;p&gt;sp&amp;amp;nbsp_place_holder;TStoredProc&lt;/p&gt;
&lt;p&gt;db&amp;amp;nbsp_place_holder;TDataBase&lt;/p&gt;
&lt;p&gt;ssn&amp;amp;nbsp_place_holder;TSession&lt;/p&gt;
&lt;p&gt;bm&amp;amp;nbsp_place_holder;TBatchMove&lt;/p&gt;
&lt;p&gt;usql&amp;amp;nbsp_place_holder;TUpdateSQL&lt;/p&gt;
&lt;p&gt;3.8.2.7&amp;amp;nbsp_place_holder;Data&amp;amp;nbsp_place_holder;Controls&amp;amp;nbsp_place_holder;Ta
b&lt;/p&gt;
&lt;p&gt;dbg&amp;amp;nbsp_place_holder;TDBGrid&lt;/p&gt;
&lt;p&gt;dbn&amp;amp;nbsp_place_holder;TDBNavigator&lt;/p&gt;
&lt;p&gt;dbt&amp;amp;nbsp_place_holder;TDBText&lt;/p&gt;
&lt;p&gt;dbe&amp;amp;nbsp_place_holder;TDBEdit&lt;/p&gt;
&lt;p&gt;dbm&amp;amp;nbsp_place_holder;TDBMemo&lt;/p&gt;
&lt;p&gt;dbi&amp;amp;nbsp_place_holder;TDBImage&lt;/p&gt;
&lt;p&gt;dblb&amp;amp;nbsp_place_holder;TDBListBox&lt;/p&gt;
&lt;p&gt;dbcb&amp;amp;nbsp_place_holder;TDBComboBox&lt;/p&gt;
&lt;p&gt;dbch&amp;amp;nbsp_place_holder;TDBCheckBox&lt;/p&gt;
&lt;p&gt;dbrg&amp;amp;nbsp_place_holder;TDBRadioGroup&lt;/p&gt;
&lt;p&gt;dbll&amp;amp;nbsp_place_holder;TDBLookupListBox&lt;/p&gt;
&lt;p&gt;dblc&amp;amp;nbsp_place_holder;TDBLookupComboBox&lt;/p&gt;
&lt;p&gt;dbre&amp;amp;nbsp_place_holder;TDBRichEdit&lt;/p&gt;
&lt;p&gt;dbcg&amp;amp;nbsp_place_holder;TDBCtrlGrid&lt;/p&gt;
&lt;p&gt;dbch&amp;amp;nbsp_place_holder;TDBChart&lt;/p&gt;
&lt;p&gt;3.8.2.8&amp;amp;nbsp_place_holder;Decision&amp;amp;nbsp_place_holder;Cube&amp;amp;nbsp_place_holder;Ta
b&lt;/p&gt;
&lt;p&gt;dcb&amp;amp;nbsp_place_holder;TDecisionCube&lt;/p&gt;
&lt;p&gt;dcq&amp;amp;nbsp_place_holder;TDecisionQuery&lt;/p&gt;
&lt;p&gt;dcs&amp;amp;nbsp_place_holder;TDecisionSource&lt;/p&gt;
&lt;p&gt;dcp&amp;amp;nbsp_place_holder;TDecisionPivot&lt;/p&gt;
&lt;p&gt;dcg&amp;amp;nbsp_place_holder;TDecisionGrid&lt;/p&gt;
&lt;p&gt;dcgr&amp;amp;nbsp_place_holder;TDecisionGraph&lt;/p&gt;
&lt;p&gt;3.8.2.9&amp;amp;nbsp_place_holder;QReport&amp;amp;nbsp_place_holder;Tab&lt;/p&gt;
&lt;p&gt;qr&amp;amp;nbsp_place_holder;TQuickReport&lt;/p&gt;
&lt;p&gt;qrsd&amp;amp;nbsp_place_holder;TQRSubDetail&lt;/p&gt;
&lt;p&gt;qrb&amp;amp;nbsp_place_holder;TQRBand&lt;/p&gt;
&lt;p&gt;qrcb&amp;amp;nbsp_place_holder;TQRChildBand&lt;/p&gt;
&lt;p&gt;qrg&amp;amp;nbsp_place_holder;TQRGroup&lt;/p&gt;
&lt;p&gt;qrl&amp;amp;nbsp_place_holder;TQRLabel&lt;/p&gt;
&lt;p&gt;qrt&amp;amp;nbsp_place_holder;TQRText&lt;/p&gt;
&lt;p&gt;qre&amp;amp;nbsp_place_holder;TQRExpr&lt;/p&gt;
&lt;p&gt;qrs&amp;amp;nbsp_place_holder;TQRSysData&lt;/p&gt;
&lt;p&gt;qrm&amp;amp;nbsp_place_holder;TQRMemo&lt;/p&gt;
&lt;p&gt;qrrt&amp;amp;nbsp_place_holder;TQRRichText&lt;/p&gt;
&lt;p&gt;qrdr&amp;amp;nbsp_place_holder;TQRDBRichText&lt;/p&gt;
&lt;p&gt;qrsh&amp;amp;nbsp_place_holder;TQRShape&lt;/p&gt;
&lt;p&gt;qri&amp;amp;nbsp_place_holder;TQRImage&lt;/p&gt;
&lt;p&gt;qrdi&amp;amp;nbsp_place_holder;TQRDBMImage&lt;/p&gt;
&lt;p&gt;qrcr&amp;amp;nbsp_place_holder;TQRCompositeReport&lt;/p&gt;
&lt;p&gt;qrp&amp;amp;nbsp_place_holder;TQRPreview&lt;/p&gt;
&lt;p&gt;qrch&amp;amp;nbsp_place_holder;TQRChart&lt;/p&gt;
&lt;p&gt;3.8.2.10&amp;amp;nbsp_place_holder;Dialogs&amp;amp;nbsp_place_holder;Tab&lt;/p&gt;
&lt;p&gt;OpenDialog&amp;amp;nbsp_place_holder;TOpenDialog&lt;/p&gt;
&lt;p&gt;SaveDialog&amp;amp;nbsp_place_holder;TSaveDialog&lt;/p&gt;
&lt;p&gt;OpenPictureDialog&amp;amp;nbsp_place_holder;TOpenPictureDialog&lt;/p&gt;
&lt;p&gt;SavePictureDialog&amp;amp;nbsp_place_holder;TSavePictureDialog&lt;/p&gt;
&lt;p&gt;FontDialog&amp;amp;nbsp_place_holder;TFontDialog&lt;/p&gt;
&lt;p&gt;ColorDialog&amp;amp;nbsp_place_holder;TColorDialog&lt;/p&gt;
&lt;p&gt;PrintDialog&amp;amp;nbsp_place_holder;TPrintDialog&lt;/p&gt;
&lt;p&gt;PrinterSetupDialog&amp;amp;nbsp_place_holder;TPrintSetupDialog&lt;/p&gt;
&lt;p&gt;FindDialog&amp;amp;nbsp_place_holder;TFindDialog&lt;/p&gt;
&lt;p&gt;ReplaceDialog&amp;amp;nbsp_place_holder;TReplaceDialog&lt;/p&gt;
&lt;p&gt;3.8.2.11&amp;amp;nbsp_place_holder;Win31&amp;amp;nbsp_place_holder;Tab&lt;/p&gt;
&lt;p&gt;dbll&amp;amp;nbsp_place_holder;TDBLookupList&lt;/p&gt;
&lt;p&gt;dblc&amp;amp;nbsp_place_holder;TDBLookupCombo&lt;/p&gt;
&lt;p&gt;ts&amp;amp;nbsp_place_holder;TTabSet&lt;/p&gt;
&lt;p&gt;ol&amp;amp;nbsp_place_holder;TOutline&lt;/p&gt;
&lt;p&gt;tnb&amp;amp;nbsp_place_holder;TTabbedNoteBook&lt;/p&gt;
&lt;p&gt;nb&amp;amp;nbsp_place_holder;TNoteBook&lt;/p&gt;
&lt;p&gt;hdr&amp;amp;nbsp_place_holder;THeader&lt;/p&gt;
&lt;p&gt;flb&amp;amp;nbsp_place_holder;TFileListBox&lt;/p&gt;
&lt;p&gt;dlb&amp;amp;nbsp_place_holder;TDirectoryListBox&lt;/p&gt;
&lt;p&gt;dcb&amp;amp;nbsp_place_holder;TDriveComboBox&lt;/p&gt;
&lt;p&gt;fcb&amp;amp;nbsp_place_holder;TFilterComboBox&lt;/p&gt;
&lt;p&gt;3.8.2.12&amp;amp;nbsp_place_holder;Samples&amp;amp;nbsp_place_holder;Tab&lt;/p&gt;
&lt;p&gt;gg&amp;amp;nbsp_place_holder;TGauge&lt;/p&gt;
&lt;p&gt;cg&amp;amp;nbsp_place_holder;TColorGrid&lt;/p&gt;
&lt;p&gt;spb&amp;amp;nbsp_place_holder;TSpinButton&lt;/p&gt;
&lt;p&gt;spe&amp;amp;nbsp_place_holder;TSpinEdit&lt;/p&gt;
&lt;p&gt;dol&amp;amp;nbsp_place_holder;TDirectoryOutline&lt;/p&gt;
&lt;p&gt;cal&amp;amp;nbsp_place_holder;TCalendar&lt;/p&gt;
&lt;p&gt;ibea&amp;amp;nbsp_place_holder;TIBEventAlerter&lt;/p&gt;
&lt;p&gt;3.8.2.13&amp;amp;nbsp_place_holder;ActiveX&amp;amp;nbsp_place_holder;Tab&lt;/p&gt;
&lt;p&gt;cfx&amp;amp;nbsp_place_holder;TChartFX&lt;/p&gt;
&lt;p&gt;vsp&amp;amp;nbsp_place_holder;TVSSpell&lt;/p&gt;
&lt;p&gt;f1b&amp;amp;nbsp_place_holder;TF1Book&lt;/p&gt;
&lt;p&gt;vtc&amp;amp;nbsp_place_holder;TVTChart&lt;/p&gt;
&lt;p&gt;grp&amp;amp;nbsp_place_holder;TGraph&lt;/p&gt;
&lt;p&gt;3.8.2.14&amp;amp;nbsp_place_holder;Midas&amp;amp;nbsp_place_holder;Tab&lt;/p&gt;
&lt;p&gt;prv&amp;amp;nbsp_place_holder;TProvider&lt;/p&gt;
&lt;p&gt;cds&amp;amp;nbsp_place_holder;TClientDataSet&lt;/p&gt;
&lt;p&gt;qcds&amp;amp;nbsp_place_holder;TQueryClientDataSet&lt;/p&gt;
&lt;p&gt;dcom&amp;amp;nbsp_place_holder;TDCOMConnection&lt;/p&gt;
&lt;p&gt;olee&amp;amp;nbsp_place_holder;TOleEnterpriseConnection&lt;/p&gt;
&lt;p&gt;sck&amp;amp;nbsp_place_holder;TSocketConnection&lt;/p&gt;
&lt;p&gt;rms&amp;amp;nbsp_place_holder;TRemoteServer&lt;/p&gt;
&lt;p&gt;mid&amp;amp;nbsp_place_holder;TmidasConnection&lt;/p&gt;
&lt;h2&gt;4．修改规范&lt;/h2&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;本规则所做的规定仅适用于已经纳入配置管理的程序。在这类修改中，要求保留修改前的内容、并标识出修改和新增的内容。并在文件
头加入修改人、修改日期、修改说明等必要的信息。&lt;/p&gt;
&lt;h3&gt;4．1修改历史记录&lt;/h3&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;对源文件进行经过批准的修改时，修改者应在程序文件头加入修改历史项。在以后的每一次修改时，修改者都必须在该项目中填写下列
信息：&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;修改人&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;修改时间&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;修改原因&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;修改说明即如何修改&lt;/p&gt;
&lt;h3&gt;4．2新增代码行&lt;/h3&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;新增代码行的前后应有注释行说明。&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;//&amp;amp;nbsp_place_holder;修改人，修改时间，修改说明&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;新增代码行&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;//&amp;amp;nbsp_place_holder;修改结束&lt;/p&gt;
&lt;h3&gt;4．3删除代码行&lt;/h3&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;删除代码行的前后用注释行说明。&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;//修改人，修改时间，修改说明&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;//要删除的代码行（将要删除的语句进行注释）&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;//修改结束&lt;/p&gt;
&lt;h3&gt;4．4修改代码行&lt;/h3&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;修改代码行以删除代码行后在新增代码行的方式进行。&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;//修改人，修改时间，修改说明&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;//修改前的代码行&lt;/p&gt;
&lt;p&gt;//修改结束&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;//修改后的代码行&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;修改后的代码行&lt;/p&gt;
&lt;p&gt;//修改结束&lt;/p&gt;</summary><category term=""></category></entry><entry><title>一个C++程序员的Delphi学习笔记【转】</title><link href="/2009/11/a-c-programmers-delphi-study-notes/" rel="alternate"></link><updated>2009-11-29T00:00:00+08:00</updated><author><name>alswl</name></author><id>tag:,2009-11-29:2009/11/a-c-programmers-delphi-study-notes/</id><summary type="html">&lt;p&gt;&amp;amp;nbsp_place_holder;早晨起来就看到这篇好文章，转载过来。&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://hi.csdn.net/Dream_soft"&gt;Dream_soft&lt;/a&gt;(via CSDN)&lt;/p&gt;
&lt;p&gt;原文链接：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/Dream_soft/archive/2001/09/17/12979.aspx"&gt;一个C++程序员的Delphi学习笔记 - Dream_soft的专栏 -
CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/Dream_soft/archive/2001/09/19/12980.aspx"&gt;一个C++程序员的Delphi学习笔记(2) - Dream_soft的专栏 -
CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者的学习经历和我比较类似，视角也比我广阔，这篇文章对程序员学习Delphi很有参考价值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;*&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;*&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;*&lt;/em&gt;&lt;/strong&gt;以下为原文&lt;strong&gt;&lt;em&gt;*&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;*&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;*&lt;/strong&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;说心里话，站在一个C++程序员的立场，是有那么一点看不上用Delphi的开发者的。就几周前，我还撰文维护过C++的尊严。种种原因，今天我却须学习Delphi
、熟悉Delphi，不由兴起人生无常的感慨。&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder; 我给了自己十五天的时间，不知够否掌握一门语言？我选择了Marco
cantu的《Delphi从入门到精通》及《Delphi高级开发指南》作为学习用书。第一本书名叫《从入门到精通》，但如果你不熟悉一门OOP语言，
那这本书不合适你。对我，则正合适。二书总厚度共一千五百页，嗯，一天一百页就差不多了，希望自己能做到吧。&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;
我决定如实记下自己的思考与困惑，做为自己进军新领域的记念，也希望能为后行的同路者提供一点帮助。&lt;/p&gt;
&lt;h2&gt;一 环境&lt;/h2&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder; "工欲善其事，必先利其器"，对开发环境的
熟悉是非常重要的。不同于VC的MDI界面，Delphi采用了多个独立窗体设计。这是否预示Borland更提倡组件间进行对等的交互？我暗暗猜测着。&lt;/p&gt;
&lt;p&gt;1.Desktop设置是可以与Project分离的，而且Desktop设置优先于Project设置。&lt;/p&gt;
&lt;p&gt;2.To-Do列表无论是用于提醒自己还是别人，都是好工具。&lt;/p&gt;
&lt;p&gt;3.AppBrowser感觉上很相似于VC的主界面。也提供了符号提示，Code Completiont等功能。嗯，还有VC所没有的Class
Completion，可以在声明和实现间双向自动补完。&lt;/p&gt;
&lt;p&gt;4.Project Group的概念，有点像.net平台中的Solution，不过.net是多语言协作的。&lt;/p&gt;
&lt;h2&gt;二 语言&lt;/h2&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder; &amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;
Delphi的核心是VCL库，其基础是Object
Pascal。《从入门到精通》用两章的篇幅细说"Object",却只字没有提到"Pascal"。嗯，还好，我隐隐记得。&lt;/p&gt;
&lt;p&gt;1.Use用于引用外部单元。与头文件不同，Use没有传递性。&lt;/p&gt;
&lt;p&gt;2.Delphi使用引用对象模型，对象变量只持有对象引用，不再持有对象本身，所有对象手动自堆中分配。&lt;/p&gt;
&lt;p&gt;3.Delphi的封装很奇怪，类成员访问权限的设定，只对单元外部起作用。在单元内，可以自对象外部任意访问类私有成员。朋友解释说相当于C++
的友元，细想其实差异很大--友谊一定是双向的吗？（将Unit方式用作友元，A能访问B，B一定能访问A）友谊有传递性吗？（将Unit方式用作友
元，A能访问B，B能访问C，A一定能访问C）。在我看来，这和友员的概念是不相容的。希望某天我能明白Delphi如此设计的考量。&lt;/p&gt;
&lt;p&gt;4.在声明对象变量后，Delphi对象的实际生成需调用构造器。构造器是特殊的类方法，自TObject继承并可重载。不使用关键字而用类方法构造对象，我认为这是
单根继承的特有用法。&lt;/p&gt;
&lt;p&gt;5.书中有一段动态创建TButton的例子，使用Creat创建了对象，却没用Free显式的释放&lt;/p&gt;
&lt;p&gt;。我疑心会发生内存泄漏，细细想来，该是由持有TButton的容器TForm来负责释放，朋友证实了我的想法。Delphi以此避免了手动释放内存的麻烦。&lt;/p&gt;
&lt;p&gt;6.Delphi的关键字很烦，长而多，要键入的地方也多。好处是能为编译器提供更多的信息，用以查错和加快编译速度。&lt;/p&gt;
&lt;p&gt;7.因着引用对象模型，不再有C++中直接对象访问无多态，只在指针和引用下多态机制才起作用的问题。&lt;/p&gt;
&lt;p&gt;8.用message直接指出方法可以处理的事件，唉，让我想起OWL时Borland对C++语言的相似扩展，真是怀念。&lt;/p&gt;
&lt;p&gt;9.大量使用动态类型转换，该是Pascal本就具有的特点吧？&lt;/p&gt;
&lt;p&gt;10.窗体继承，好像连控件的属性都可以继承呢。&lt;/p&gt;
&lt;p&gt;11.很奇怪的设计。有类方法，却不提供类变量，需用Unit级的变量来模拟。&lt;/p&gt;
&lt;p&gt;12.如果我的猜想不错，控件的Events应该就是"对象方法指针"。&lt;/p&gt;
&lt;p&gt;13.极强有力的机制：类引用，可用相同的形式动态建立不同的数据类型。C++中相似的能力，怕要用Builder模式才行。&lt;/p&gt;
&lt;p&gt;14.参数对象按引用传递，按引用赋值，只有部分类提供Assign方法复制对像。唉，C++的值语意，好怀念。&lt;/p&gt;
&lt;p&gt;15.Finally块！解决了C++中好些需高度技巧的资源释放问题。但为什么不能和except一起使用？不太明白。&lt;/p&gt;
&lt;p&gt;16.属性和事件？？真是为VCL量身定制的语言啊。其实属性和事件并非面向对象的必要元素。&lt;/p&gt;
&lt;p&gt;17.我想VCL事件处理的委托模型，该是与JAVA相似的。只是Java的Listener可以处理多&lt;/p&gt;
&lt;p&gt;个Listener的存在，Delphi的事件属性好像只能处理一个吧？不过处理速度上要快多了。&lt;/p&gt;
&lt;p&gt;18.a)从TComponent类继承，b)新构造程序,c)例行的Register,d)安装。VCL组件创建的方便，真让人感动。&lt;/p&gt;
&lt;p&gt;19.书上说VCL优于ActiveX，因为ActiveX没有完全的继承机制，我不敢苟同。聚合该是先于继承选用的机制。&lt;/p&gt;
&lt;p&gt;20.Interface，丑死了！！我甚至怀疑这是否Hejlsberg的设计。完全像是为Com支持临时拼凑的语言成份，与整体毫不协调，像个
外来户。接口本身是强大的东西，但糟糕的设计会让它的使用成为一种痛苦。除了COM和多重继承没有选择外，我想是没人愿意用它的。&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder; 整个来说，Object
pascal给我很深的映象。接下来就该学习VCL了，且看Borland是如何将这种种语言的成份，组装成为开发的利器。(续待）&lt;/p&gt;
&lt;h2&gt;三 VCL&lt;/h2&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder; 《从入门到精通》，作者的安排可真大胆。不先讲如何在Form上摆控件，倒自VCL
讲起。我佩服作者的气魄，直直的深入到问题的核心，剔筋去肉，先将脉络端到你的面前。要知道，这有着失去很多读者的危险。&lt;/p&gt;
&lt;p&gt;1.TObject，万类之源。RTTI信息就放在这里了，这算是单根单继承实现上的便利吧。&lt;/p&gt;
&lt;p&gt;2.一个细节：TButton.InstanceSize=504！真够浪费的。算法分析中常讲以空间换时间，这该算以空间换宜用性吧。&lt;/p&gt;
&lt;p&gt;3.作为TPersisitent的子类，TComponet拥有流化能力。IDE就用其将属性写入DFM文件中。&lt;/p&gt;
&lt;p&gt;4.TPersisitent委托TFiler和TStream两个辅助类来具体实现流化。具体实现中包括自RTTI中读出子类所有拥有的属性，使流化对程序员透明。&lt;/p&gt;
&lt;p&gt;5.非窗口控件？相信是对效率低的一种补偿。&lt;/p&gt;
&lt;p&gt;6.Componentsk中包含窗体所有上的控件，即使他们的Parent为别的组件容器，其Owner也是Form.&lt;/p&gt;
&lt;p&gt;7.Owner和Parent,两个易混淆的概念。我的理解：Owner是对象的持有者，Parent是对象的呈现者。&lt;/p&gt;
&lt;p&gt;8.窗体元素没有进行封装！带来访问的便利性的同时，也留下混乱的隐患，特别在大型工程中。&lt;/p&gt;
&lt;p&gt;9.控件位置的坐标原点对应Parent的客户区，这加强了我的信心：Parent是对象的呈现者。&lt;/p&gt;
&lt;p&gt;10.Frames，窗体继承的有力竞争者。其本质是以聚合代替继承。昨天有朋友提出："我觉得聚合是不可以取代继承
的"。的确，聚合不可能完全代替继承，但在两者同时适用的条件下，应该选择耦合较为松散、封装更为完全的聚合。具体到Frames和窗体继承来说，我感觉
在不涉及多态时，是应该选用Frames的。&lt;/p&gt;
&lt;p&gt;11.Delphi提供的容器类，与C++的STL相比，从弹性到效率可就差远了，还容易出现类型安全问题。还好Delphi的RTTI机制强大，可以略补不足。这该
是没有模板机制的副作用：整个的泛型思想都用不上。&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;
其实作者还是很为初学者着想的：并没有深入VCL。虽有点意犹未尽，但作为初学的我，也该是知足了。&lt;/p&gt;
&lt;h2&gt;四：标准组件&lt;/h2&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;
其实很多Delphi的使用者，都是看中众多的VCL组件支持。有朋友对我前文所说"其实属性和事件并非面向对象的必要元素"表示不敢苟同，我相信他是混
淆面向对象和面向组件了。在我的记忆中，面向组件是面对对象的扩展，其本质虽仍是面向对象，但为之添加了众多的辅助特性，其中就包括属性（不是C++的"
属性"）和事件。&lt;/p&gt;
&lt;p&gt;1.Form的Components，GroupBox的Controls，ListBox的Items，Delphi还真是喜欢用数组容器来表达组织结构。&lt;/p&gt;
&lt;p&gt;2.还有sleected数组，ItemEnabled数组，哦，值也是通过Items数组的对应项来存储的。&lt;/p&gt;
&lt;p&gt;3.Drag-Drop。看到书的标题，不由的就想到IDataObject、IDropSource、
IDropTarget几个接口。其实Delphi的拖放要简单很多。就我的了解，本质是一个Drop通知，不像Com会将数据本身包装好传送。这该是不
需支持跨进程Drag-Drop的原因吧。&lt;/p&gt;
&lt;p&gt;4.菜单不再做为资源出现，呈现给应用程序员的，是其包装后的TMenuItem和组织成嵌套形式的Items。两个优点：a)纯一，不再有菜单资源需程序员理解。2
)在包装层中括展菜单功能极为方便，并对程序员透明。为此，ImageList也进行相应包装。&lt;/p&gt;
&lt;p&gt;5.Action，其实质为双向事件转发：各客户控件-&amp;gt;Action-&amp;gt;OnExecute，OnUpdata-&amp;gt;Action属性改变-&amp;gt;各客户控件。&lt;/p&gt;
&lt;p&gt;6.Owner-draw，还是定制控件画出自身？一个两难的选择。从一个OO纯化论者的角度看，Owner-
draw实在是对封装的一种破坏。定制控件画出自身，却又未免劳民伤财，浪费资源。&lt;/p&gt;
&lt;p&gt;7.TreeView，树状视图。XML不正是擅长树的表达吗？干嘛不给他们结合结合？&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder;
唉，操作性的东西，能想的能写的实在不多，对吧？希望接下来的几章，能激荡起脑力才是。&lt;/p&gt;</summary><category term=""></category></entry><entry><title>Delphi学习笔记03</title><link href="/2009/11/delphi-study-notes-03/" rel="alternate"></link><updated>2009-11-29T00:00:00+08:00</updated><author><name>alswl</name></author><id>tag:,2009-11-29:2009/11/delphi-study-notes-03/</id><summary type="html">&lt;p&gt;学习Delphi第三天，早晨起来之后跑去图书馆找了一本书《&lt;a href="http://www.china-
pub.com/36610"&gt;Delphi开发经验技巧宝典&lt;/a&gt;》，翻开这本书发现更适合作为手册查阅，而不是学习教材。最后借了一本《&lt;a href="http://www
.china-pub.com/734474"&gt;Delphi面向对象程序设计&lt;/a&gt;》的教材，属于"21世纪高等学校应用型教材"系列。&lt;/p&gt;
&lt;p&gt;今天主要完成了Pascal到Delphi的过度，学习使用&lt;strong&gt;集合set&lt;/strong&gt;、&lt;strong&gt;记录record&lt;/strong&gt;、&lt;strong&gt;指针Pointer&lt;/strong&gt;和&lt;strong&gt;简单的可视化编程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在百度&lt;a href="http://tieba.baidu.com/f?kw=delphi"&gt;Delphi吧&lt;/a&gt;逛时候发现&lt;a href="http://passport.ba
idu.com/?business&amp;amp;un=%CB%F7%D2%FD%D4%BD%BD%E7#0"&gt;索引越界&lt;/a&gt;居然是Delphi吧主，里面有一篇文章关于&lt;a href="http://tieba.baidu.com/f?kz=84767888"&gt;Delphi的编
码风格&lt;/a&gt;，我一会转过来。&lt;/p&gt;
&lt;p&gt;Ps:啊，你不知道索引越界？！那百度贴吧伴侣总应该听过吧，偷偷告诉你，这个软件就是索引越界用Delphi开发的。&lt;/p&gt;
&lt;p&gt;好了，下面是正文，我今天使用的代码，咱们让代码来反应思想吧（其实我是懒得总结每个用法~）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;program&lt;/span&gt; &lt;span class="n"&gt;P2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;集合、记录、指针学习&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;APPTYPE&lt;/span&gt; &lt;span class="n"&gt;CONSOLE&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;uses&lt;/p&gt;
&lt;p&gt;SysUtils;&lt;/p&gt;
&lt;p&gt;{集合set}&lt;/p&gt;
&lt;p&gt;procedure SetTest();&lt;/p&gt;
&lt;p&gt;type&lt;/p&gt;
&lt;p&gt;{定义子集类型,子集类型元素不能超过256}&lt;/p&gt;
&lt;p&gt;TSomeInts = 1..250;&lt;/p&gt;
&lt;p&gt;TIntSet = set of TSomeInts;&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;set1, set2 : TIntSet;&lt;/p&gt;
&lt;p&gt;i : integer;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;set1 := [1, 3, 5, 7, 9];&lt;/p&gt;
&lt;p&gt;set2 := [2, 4, 6, 8, 10];&lt;/p&gt;
&lt;p&gt;{似乎Pascal不能输出Set内元素，书上解释是&lt;/p&gt;
&lt;p&gt;因为Set是无序的，只能使用下列方式来判断。&lt;/p&gt;
&lt;p&gt;使用Low()/Hign()函数获得有序数据类型的边&lt;/p&gt;
&lt;p&gt;界。}&lt;/p&gt;
&lt;p&gt;for i:= Low(TSomeInts) to High(TSomeInts) do&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;{Set有一套操作方法，就是并、交、叉、等于&lt;/p&gt;
&lt;p&gt;、不等于、属于，下面就是用到属于in}&lt;/p&gt;
&lt;p&gt;if i in set1 then Write(i);&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;Writeln;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;{记录record}&lt;/p&gt;
&lt;p&gt;procedure RecordTest ();&lt;/p&gt;
&lt;p&gt;type&lt;/p&gt;
&lt;p&gt;{这是定义一个记录，类似于结构体}&lt;/p&gt;
&lt;p&gt;TStudent = record&lt;/p&gt;
&lt;p&gt;StNumber : integer;&lt;/p&gt;
&lt;p&gt;StName : string;&lt;/p&gt;
&lt;p&gt;stScore : Real;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;{其实我对这里的数据初始化不太懂，也许&lt;/p&gt;
&lt;p&gt;是因为受C++/Java影响，我始终觉得应该&lt;/p&gt;
&lt;p&gt;有一个构造过程，不知道这一个构造过程&lt;/p&gt;
&lt;p&gt;是在var实现还是在给成员变量初次赋值实&lt;/p&gt;
&lt;p&gt;现。}&lt;/p&gt;
&lt;p&gt;student1 : TStudent;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;student1.StNumber := 1000;&lt;/p&gt;
&lt;p&gt;student1.StName := '张三';&lt;/p&gt;
&lt;p&gt;student1.stScore := 85.5;&lt;/p&gt;
&lt;p&gt;Writeln(student1.StName);&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;{指针}&lt;/p&gt;
&lt;p&gt;procedure PointerTest ();&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;{定义指针}&lt;/p&gt;
&lt;p&gt;p1, p2 : ^integer;&lt;/p&gt;
&lt;p&gt;x : integer;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;x := 100;&lt;/p&gt;
&lt;p&gt;{使用@取变量地址}&lt;/p&gt;
&lt;p&gt;p1 := @x;&lt;/p&gt;
&lt;p&gt;Writeln('x = ', x);&lt;/p&gt;
&lt;p&gt;{注意^的使用}&lt;/p&gt;
&lt;p&gt;Writeln('p1^ = ', p1^);&lt;/p&gt;
&lt;p&gt;{使用New()对指针分配内存空间&lt;/p&gt;
&lt;p&gt;ps；Object Pascal有一种Pointer类型，使用GetMem()&lt;/p&gt;
&lt;p&gt;来分配未知大小内存情况，Pointer表示无类型指针。}&lt;/p&gt;
&lt;p&gt;New(p2);&lt;/p&gt;
&lt;p&gt;p2^ := 20;&lt;/p&gt;
&lt;p&gt;Writeln('p2 = ', p2^);&lt;/p&gt;
&lt;p&gt;{使用Dispose()释放内存空间}&lt;/p&gt;
&lt;p&gt;Dispose(p2);&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;SetTest();&lt;/p&gt;
&lt;p&gt;RecordTest();&lt;/p&gt;
&lt;p&gt;PointerTest ();&lt;/p&gt;
&lt;p&gt;Readln;&lt;/p&gt;
&lt;p&gt;end.&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;下面是一个学生分数登记系统，用了&lt;code&gt;TEdit/TRadioGroup/TListBox&lt;/code&gt;等简单控件。整个项目一共三个文
件"&lt;code&gt;P3.dpr&lt;/code&gt;"、"&lt;code&gt;UScore.dfm&lt;/code&gt;"、"&lt;code&gt;UScore.pas&lt;/code&gt;"，分别是项目文件、窗体文件、模块文件。下面是对应的代码（我发现Delphi
7想在代码状态编辑.dpr/.dfm这种文件特别麻烦）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;program&lt;/span&gt; &lt;span class="n"&gt;P3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;项目文件，也是入口程序，相当于&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="err"&gt;#的&lt;/span&gt;&lt;span class="n"&gt;application&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;uses&lt;/span&gt;
  &lt;span class="n"&gt;Forms&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;UScore&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;UScore&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pas&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;FrmScore&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{$R *.res}&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;{Hejlsberg不愧是Delphi/C#之父，如此神似}&lt;/p&gt;
&lt;p&gt;Application.Initialize;&lt;/p&gt;
&lt;p&gt;Application.CreateForm(TFrmScore, FrmScore);&lt;/p&gt;
&lt;p&gt;Application.Run;&lt;/p&gt;
&lt;p&gt;end.&lt;/p&gt;
&lt;p&gt;下面是窗体文件UScore.dfm，注释始终无法加入。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="n"&gt;FrmScore&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;TFrmScore&lt;/span&gt;
  &lt;span class="n"&gt;Left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;612&lt;/span&gt;
  &lt;span class="n"&gt;Top&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;163&lt;/span&gt;
  &lt;span class="n"&gt;Width&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;315&lt;/span&gt;
  &lt;span class="n"&gt;Height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;389&lt;/span&gt;
  &lt;span class="n"&gt;Caption&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;Student&lt;/span&gt; &lt;span class="n"&gt;Score&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
  &lt;span class="n"&gt;Color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;clBtnFace&lt;/span&gt;
  &lt;span class="n"&gt;Font&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Charset&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DEFAULT_CHARSET&lt;/span&gt;
  &lt;span class="n"&gt;Font&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;clWindowText&lt;/span&gt;
  &lt;span class="n"&gt;Font&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt;
  &lt;span class="n"&gt;Font&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;MS&lt;/span&gt; &lt;span class="n"&gt;Sans&lt;/span&gt; &lt;span class="n"&gt;Serif&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
  &lt;span class="n"&gt;Font&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Style&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
  &lt;span class="n"&gt;OldCreateOrder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;False&lt;/span&gt;
  &lt;span class="n"&gt;PixelsPerInch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;96&lt;/span&gt;
  &lt;span class="n"&gt;TextHeight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;
  &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="n"&gt;edtNo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;TEdit&lt;/span&gt;
    &lt;span class="n"&gt;Left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;
    &lt;span class="n"&gt;Top&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;
    &lt;span class="n"&gt;Width&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;121&lt;/span&gt;
    &lt;span class="n"&gt;Height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;
    &lt;span class="n"&gt;TabOrder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
  &lt;span class="n"&gt;end&lt;/span&gt;
  &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="n"&gt;edtName&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;TEdit&lt;/span&gt;
    &lt;span class="n"&gt;Left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;
    &lt;span class="n"&gt;Top&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;72&lt;/span&gt;
    &lt;span class="n"&gt;Width&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;121&lt;/span&gt;
    &lt;span class="n"&gt;Height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;
    &lt;span class="n"&gt;TabOrder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
  &lt;span class="n"&gt;end&lt;/span&gt;
  &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="n"&gt;rgSex&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;TRadioGroup&lt;/span&gt;
    &lt;span class="n"&gt;Left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;176&lt;/span&gt;
    &lt;span class="n"&gt;Top&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;
    &lt;span class="n"&gt;Width&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;105&lt;/span&gt;
    &lt;span class="n"&gt;Height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;65&lt;/span&gt;
    &lt;span class="n"&gt;Caption&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;24615&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;21035&lt;/span&gt;
    &lt;span class="n"&gt;ItemIndex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;Items&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Strings&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
      &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;30007&lt;/span&gt;
      &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;22899&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;TabOrder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
  &lt;span class="n"&gt;end&lt;/span&gt;
  &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="n"&gt;gbScore&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;TGroupBox&lt;/span&gt;
    &lt;span class="n"&gt;Left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;
    &lt;span class="n"&gt;Top&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;112&lt;/span&gt;
    &lt;span class="n"&gt;Width&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;249&lt;/span&gt;
    &lt;span class="n"&gt;Height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;81&lt;/span&gt;
    &lt;span class="n"&gt;Caption&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;gbScore&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;TabOrder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
    &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="n"&gt;edtChinese&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;TEdit&lt;/span&gt;
      &lt;span class="n"&gt;Left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;
      &lt;span class="n"&gt;Top&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;
      &lt;span class="n"&gt;Width&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;121&lt;/span&gt;
      &lt;span class="n"&gt;Height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;
      &lt;span class="n"&gt;TabOrder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="n"&gt;edtMath&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;TEdit&lt;/span&gt;
      &lt;span class="n"&gt;Left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;
      &lt;span class="n"&gt;Top&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;48&lt;/span&gt;
      &lt;span class="n"&gt;Width&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;121&lt;/span&gt;
      &lt;span class="n"&gt;Height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;
      &lt;span class="n"&gt;TabOrder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
  &lt;span class="n"&gt;end&lt;/span&gt;
  &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="n"&gt;lbDisplay&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;TListBox&lt;/span&gt;
    &lt;span class="n"&gt;Left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;
    &lt;span class="n"&gt;Top&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;248&lt;/span&gt;
    &lt;span class="n"&gt;Width&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;249&lt;/span&gt;
    &lt;span class="n"&gt;Height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;105&lt;/span&gt;
    &lt;span class="n"&gt;ItemHeight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;
    &lt;span class="n"&gt;TabOrder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
  &lt;span class="n"&gt;end&lt;/span&gt;
  &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="n"&gt;btnAdd&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;TButton&lt;/span&gt;
    &lt;span class="n"&gt;Left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;56&lt;/span&gt;
    &lt;span class="n"&gt;Top&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;208&lt;/span&gt;
    &lt;span class="n"&gt;Width&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;75&lt;/span&gt;
    &lt;span class="n"&gt;Height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt;
    &lt;span class="n"&gt;Caption&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;btnAdd&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;TabOrder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
    &lt;span class="n"&gt;OnClick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;btnAddClick&lt;/span&gt;
  &lt;span class="n"&gt;end&lt;/span&gt;
  &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="n"&gt;btnDisplay&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;TButton&lt;/span&gt;
    &lt;span class="n"&gt;Left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;168&lt;/span&gt;
    &lt;span class="n"&gt;Top&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;208&lt;/span&gt;
    &lt;span class="n"&gt;Width&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;75&lt;/span&gt;
    &lt;span class="n"&gt;Height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt;
    &lt;span class="n"&gt;Caption&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;btnDisplay&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;TabOrder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;
    &lt;span class="n"&gt;OnClick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;btnDisplayClick&lt;/span&gt;
  &lt;span class="n"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;


&lt;span class="n"&gt;unit&lt;/span&gt; &lt;span class="n"&gt;UScore&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;UScore&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pas&lt;/span&gt;&lt;span class="err"&gt;，一个模块文件&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;interface&lt;/p&gt;
&lt;p&gt;uses&lt;/p&gt;
&lt;p&gt;Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,&lt;/p&gt;
&lt;p&gt;Dialogs, StdCtrls, ExtCtrls;&lt;/p&gt;
&lt;p&gt;type&lt;/p&gt;
&lt;p&gt;TFrmScore = class(TForm)&lt;/p&gt;
&lt;p&gt;edtNo: TEdit;&lt;/p&gt;
&lt;p&gt;edtName: TEdit;&lt;/p&gt;
&lt;p&gt;rgSex: TRadioGroup;&lt;/p&gt;
&lt;p&gt;gbScore: TGroupBox;&lt;/p&gt;
&lt;p&gt;edtChinese: TEdit;&lt;/p&gt;
&lt;p&gt;edtMath: TEdit;&lt;/p&gt;
&lt;p&gt;lbDisplay: TListBox;&lt;/p&gt;
&lt;p&gt;btnAdd: TButton;&lt;/p&gt;
&lt;p&gt;btnDisplay: TButton;&lt;/p&gt;
&lt;p&gt;procedure btnAddClick(Sender: TObject);&lt;/p&gt;
&lt;p&gt;procedure btnDisplayClick(Sender: TObject);&lt;/p&gt;
&lt;p&gt;private&lt;/p&gt;
&lt;p&gt;{ Private declarations }&lt;/p&gt;
&lt;p&gt;public&lt;/p&gt;
&lt;p&gt;{ Public declarations }&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;{定义一个Student类型记录}&lt;/p&gt;
&lt;p&gt;Student = record&lt;/p&gt;
&lt;p&gt;stuNo : string[8];&lt;/p&gt;
&lt;p&gt;name : String[8];&lt;/p&gt;
&lt;p&gt;sex : String[2];&lt;/p&gt;
&lt;p&gt;chinese, math : integer;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;frmScore: TFrmScore;&lt;/p&gt;
&lt;p&gt;{定义Student类型动态数组}&lt;/p&gt;
&lt;p&gt;stus : array of Student;&lt;/p&gt;
&lt;p&gt;{我没找到这个count初始化为0，应该是自动初始化为0了}&lt;/p&gt;
&lt;p&gt;count : integer;&lt;/p&gt;
&lt;p&gt;{不知道书上原始代码定义这个file干嘛，莫非想写入文件？}&lt;/p&gt;
&lt;p&gt;f : file of Student;&lt;/p&gt;
&lt;p&gt;implementation&lt;/p&gt;
&lt;p&gt;{$R *.dfm}&lt;/p&gt;
&lt;p&gt;procedure TFrmScore.btnAddClick(Sender: TObject);&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;count := count + 1;&lt;/p&gt;
&lt;p&gt;SetLength(stus, count);&lt;/p&gt;
&lt;p&gt;{这里使用了with开域语句，省去重复输入stus}&lt;/p&gt;
&lt;p&gt;with stus[count - 1] do&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;stuNo := edtNo.Text;&lt;/p&gt;
&lt;p&gt;name := edtName.Text;&lt;/p&gt;
&lt;p&gt;if rgSex.ItemIndex = 0 then&lt;/p&gt;
&lt;p&gt;sex := '男'&lt;/p&gt;
&lt;p&gt;else&lt;/p&gt;
&lt;p&gt;sex := '女';&lt;/p&gt;
&lt;p&gt;chinese := StrToInt(edtChinese.Text);&lt;/p&gt;
&lt;p&gt;math := StrToInt(edtMath.Text);&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;ShowMessage('第' + IntToStr(count) +'条记录添加完毕。');&lt;/p&gt;
&lt;p&gt;{直接调用DisplayClick，使用Sender作为触发源}&lt;/p&gt;
&lt;p&gt;btnDisplayClick(Sender);&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;procedure TFrmScore.btnDisplayClick(Sender: TObject);&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;i : integer;&lt;/p&gt;
&lt;p&gt;s : string;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;{ListBox增加Item}&lt;/p&gt;
&lt;p&gt;lbDisplay.Items.Clear();&lt;/p&gt;
&lt;p&gt;for i := Low(stus) to High(stus) do&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;s := stus[i].stuNo + ', ' + stus[i].name + ', ' +&lt;/p&gt;
&lt;p&gt;stus[i].sex + IntToStr(stus[i].chinese) + ', ' +&lt;/p&gt;
&lt;p&gt;IntToStr(stus[i].math);&lt;/p&gt;
&lt;p&gt;lbDisplay.Items.Add(s);&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;end.&lt;/p&gt;
&lt;p&gt;这个分数记录系统的作用仅仅是为了熟悉Delphi可视化开发，没有任何可实用价值，Google过来的同学估计要哭了，哈哈~&lt;/p&gt;
&lt;p&gt;明天开始要准备Object Pascal的内容，再加强控件的认识和使用。&lt;/p&gt;</summary><category term=""></category></entry><entry><title>Delphi学习笔记01</title><link href="/2009/11/delphi-study-notes-01/" rel="alternate"></link><updated>2009-11-28T00:00:00+08:00</updated><author><name>alswl</name></author><id>tag:,2009-11-28:2009/11/delphi-study-notes-01/</id><summary type="html">&lt;p&gt;&amp;amp;nbsp_place_holder;由于工作中需要使用Dephi，而此之前我对Delphi仅限于听过而已，所以我要在极短的时间内学会一门新的语言。这对我来
说是很有挑战性，也到了证明我以前反复强调"语法不是问题，语言才是跨度"的时候。我需要掌握的是Delphi基本使用和IDE工具使用。我认为，在熟悉C/Java
/.NET的基础上快速掌握一门从未接触过的语言，并非不可完成的任务。&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;在学习这门未知的语言之前，首先要知道自己学习的是什么东西，框架如何，用来开发哪些类型应用，IDE的情况，下面给出一些简
单解释。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/zh-cn/Pascal"&gt;Pascal&lt;/a&gt;
&lt;a href="http://zh.wikipedia.org/zh-cn/Delphi"&gt;Delphi&lt;/a&gt; (via wiki)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的主要教程&lt;/strong&gt;（电子档）有如下几本：&lt;/p&gt;
&lt;p&gt;《&lt;a href="http://www.tanghu.net/gr/zhoukun/pascal/pascal5.htm"&gt;Pascal基本教程&lt;/a&gt;》([Google快照]
(http://203.208.39.132/search?q=cache:EEjmkPEDtpQJ:www.tanghu.net/gr/zhoukun/p
ascal/pascal5.htm+pascal%E6%95%99%E7%A8%8B&amp;amp;cd=1&amp;amp;hl=zh-
CN&amp;amp;ct=clnk&amp;amp;gl=cn&amp;amp;st_usg=ALhdy2-n00UsziHbgXqjlScPI4vUI2jwTw))&lt;/p&gt;
&lt;p&gt;下午在手机还能访问，晚上就无法访问了，只能从Google快照获取内容。教程中文字描述极为简单，通篇只有一页，但是浓缩的精华，对于我这种快速学习很有帮助。&lt;/p&gt;
&lt;p&gt;《&lt;a href="http://www.gougou.com/search?search=PASCAL%E8%AF%AD%E8%A8%80%E
5%9F%B9%E8%AE%AD%E6%95%99%E7%A8%8B&amp;amp;id=1"&gt;PASCAL语言培训教程&lt;/a&gt;》(via 狗狗)&lt;/p&gt;
&lt;p&gt;这个教程是信息学用到的，其中有一些例子和详细的截图（Turbo Pascal下），作为对上面Pascal基本教程的补充还是很不错的。&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;《&lt;a href="http://www.gougou.com/search?sear
ch=Delphi%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E3%80%8B-%E6%9
D%8E%E6%96%87%E6%B1%A0-%E7%94%B5%E5%AD%90%E6%95%99%E6%A1%88&amp;amp;restype=-1&amp;amp;id=1000
0001&amp;amp;ty=0&amp;amp;pattern=0&amp;amp;xmp=0"&gt;Delphi程序设计基础》-李文池-电子教案&lt;/a&gt;》(via 狗狗)&lt;/p&gt;
&lt;p&gt;这是一套PPT，应该是一本教材的原装课件，内容很丰富，很适合快速学习，Delphi 7。&lt;/p&gt;
&lt;p&gt;《&lt;a href="http://www.gougou.com/search?search=delphi%E7%BB%8F%E5%85%B8%E
7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8&amp;amp;restype=-1&amp;amp;id=10000001&amp;amp;ty=0&amp;amp;pattern=0&amp;amp;xmp=0"&gt;delphi经典编程入门&lt;/a&gt;》(via 狗狗)&lt;/p&gt;
&lt;p&gt;这是我今天找的十余本Delphi教程中最完整的，内容比较全，缺点是没有截图，版本是Delphi 2.0 -_-!&lt;/p&gt;
&lt;p&gt;我并没有去买Dephi的书，我在China-Pub上找了一会，没找到那种大家都非常认可的教材书，罢了，就电子版上阵吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Delphi的学习曲线&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一、Pascal 程序设计基础&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder; 1.1&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder; 常量和变量&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder; 1.2&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder; 数据类型&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder; 1.3&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder; 语句&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder; 1.4&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder; 过程和函数&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder; 1.5&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder; 程序和单元&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder; 1.6&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder; 嵌入式汇编&lt;/p&gt;
&lt;p&gt;二、OO（面向对象了）程序设计&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder; 2.1&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder; 基本概念&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder; 2.2&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder; 类&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder; 2.3&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder; 方法&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder; 2.4&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder; 继承和多态性&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder; 2.5&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder; 对象和VRE&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder; 2.6&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder; 属性&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder; 2.7&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder; 消息&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder; 2.8&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder; 异常处理&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder; 2.9&amp;amp;nbsp_place_holder;&amp;amp;nbsp_place_holder; VRE的实现&lt;/p&gt;
&lt;p&gt;所以第一步熟悉Pascal语法，第二步熟悉Dephi框架，第三步有时间再熟悉高阶内容，如网络编程，COM，VRE等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后来一个Delphi的Hello World!&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;program&lt;/span&gt; &lt;span class="n"&gt;Project1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{$APPTYPE CONSOLE}&lt;/p&gt;
&lt;p&gt;uses&lt;/p&gt;
&lt;p&gt;SysUtils;&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;s : String;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;Writeln('Hello world!');&lt;/p&gt;
&lt;p&gt;Readln(s);&lt;/p&gt;
&lt;p&gt;end.&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;OK，今天花了2个小时熟悉了Delphi和Pascal，才收获这么多，明天得继续努力了。&lt;/p&gt;</summary><category term="Pascal"></category></entry><entry><title>Delphi学习笔记02</title><link href="/2009/11/delphi-study-notes-02/" rel="alternate"></link><updated>2009-11-28T00:00:00+08:00</updated><author><name>alswl</name></author><id>tag:,2009-11-28:2009/11/delphi-study-notes-02/</id><summary type="html">&lt;p&gt;今天算是学习Delphi的第二天，昨天熟悉了一下基本概念和开发环境，写了一个简单的Hello world!（传送门-&lt;a href="http://log4d.com/2009/11/delphi-study-notes-01"&gt;Hello
world!&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;说是学Delphi，其实今天我一下午都在学习Pascal语法，这里有一个要点我需要强调"Delphi与其说一门语言，不如说是一个开发环境和开发框架，使用的是
Object Pascal语言"。我今天还停留在Delphi基本语法、变量、数组、指针这些学习上。&lt;/p&gt;
&lt;p&gt;说说我对Pascal的第一感觉吧：语法很繁琐，比起C/Java，&lt;code&gt;if/while/repeate/for&lt;/code&gt;这些语法结构都&lt;code&gt;begin/end&lt;/code&gt;才支持多语句
（C/Java使用{}，Python使用缩进）。不过正是这个原因，所以代码特别直观，在教学使用和信息学比赛就很适合了。&lt;/p&gt;
&lt;p&gt;今天使用的教材是《Pascal基础教程》（传送门-&lt;a href="http://log4d.com/2009/11/delphi-study-
notes-01"&gt;更多教程&lt;/a&gt;），还是那句话，相当精简，适合有编程基础的童鞋。&lt;/p&gt;
&lt;p&gt;下面是我今天使用的几个例子，我都尽量附带注释了，放在这里以后复习和分享。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常量、变量、函数、过程、If语句&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;program&lt;/span&gt; &lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;常量、变量、函数、过程、&lt;/span&gt;&lt;span class="n"&gt;If&lt;/span&gt;&lt;span class="err"&gt;语句&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;{加上$意味着编译指令}&lt;/p&gt;
&lt;p&gt;{$APPTYPE CONSOLE}&lt;/p&gt;
&lt;p&gt;uses&lt;/p&gt;
&lt;p&gt;SysUtils;&lt;/p&gt;
&lt;p&gt;const&lt;/p&gt;
&lt;p&gt;{标识符，有效长度为63个字符，并且大小写等效}&lt;/p&gt;
&lt;p&gt;{常量定义}&lt;/p&gt;
&lt;p&gt;pi = 3.14159;&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;{变量定义}&lt;/p&gt;
&lt;p&gt;s : Real;&lt;/p&gt;
&lt;p&gt;t1_ : String;&lt;/p&gt;
&lt;p&gt;_t2 : Integer;&lt;/p&gt;
&lt;p&gt;{函数}&lt;/p&gt;
&lt;p&gt;function Area(): Real;&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;r : Real;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;{输出一串字符串}&lt;/p&gt;
&lt;p&gt;Writeln('Pleae enter a number:');&lt;/p&gt;
&lt;p&gt;Readln(r);&lt;/p&gt;
&lt;p&gt;{标准函数-算术函数-sqr()}&lt;/p&gt;
&lt;p&gt;{赋值语句 :=}&lt;/p&gt;
&lt;p&gt;Area := pi * sqr(r);&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;{过程定义-打印较大值}&lt;/p&gt;
&lt;p&gt;procedure Larger(x, y : Integer);&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;{分支语句 if-then-else}&lt;/p&gt;
&lt;p&gt;if x &amp;gt; y then&lt;/p&gt;
&lt;p&gt;Write(x)&lt;/p&gt;
&lt;p&gt;else&lt;/p&gt;
&lt;p&gt;Write(y);&lt;/p&gt;
&lt;p&gt;Writeln;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;Writeln('Call Area function');&lt;/p&gt;
&lt;p&gt;{调用函数Area()}&lt;/p&gt;
&lt;p&gt;s := Area();&lt;/p&gt;
&lt;p&gt;Writeln('s = ', s);&lt;/p&gt;
&lt;p&gt;Writeln('back to main');&lt;/p&gt;
&lt;p&gt;Writeln('call Larger procedure');&lt;/p&gt;
&lt;p&gt;{调用过程Larger()}&lt;/p&gt;
&lt;p&gt;Larger(10, 9);&lt;/p&gt;
&lt;p&gt;Writeln('back to main');&lt;/p&gt;
&lt;p&gt;Readln;&lt;/p&gt;
&lt;p&gt;end.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;amp;nbsp_place_holder;学习if/case/while/repeat/for语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;program&lt;/span&gt; &lt;span class="n"&gt;P2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;学习&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;repeat&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="err"&gt;语句&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;APPTYPE&lt;/span&gt; &lt;span class="n"&gt;CONSOLE&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;uses&lt;/p&gt;
&lt;p&gt;SysUtils;&lt;/p&gt;
&lt;p&gt;{测试单语句if-then}&lt;/p&gt;
&lt;p&gt;procedure IfTest1(x : Real);&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;y : Real;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;if x &amp;gt; 0 then&lt;/p&gt;
&lt;p&gt;y := 1;&lt;/p&gt;
&lt;p&gt;if x = 0 then&lt;/p&gt;
&lt;p&gt;y := 0;&lt;/p&gt;
&lt;p&gt;if x &amp;lt; 0 then&lt;/p&gt;
&lt;p&gt;y := -1;&lt;/p&gt;
&lt;p&gt;Writeln(y);&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;{测试多语句if-then，嵌套begin-...-end语句}&lt;/p&gt;
&lt;p&gt;procedure IfTest2(x : Integer);&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;if x &amp;gt; 0 then&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;Writeln('test line1');&lt;/p&gt;
&lt;p&gt;Writeln('test line2');&lt;/p&gt;
&lt;p&gt;end&lt;/p&gt;
&lt;p&gt;else&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;Writeln('test line3');&lt;/p&gt;
&lt;p&gt;Writeln('test line4');&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;{Case语句}&lt;/p&gt;
&lt;p&gt;function CaseTest (score : Integer): Char;&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;r : Char;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;case score div 10 of&lt;/p&gt;
&lt;p&gt;10, 9 : r := 'A';&lt;/p&gt;
&lt;p&gt;8 : r := 'B';&lt;/p&gt;
&lt;p&gt;7, 6 : r := 'C';&lt;/p&gt;
&lt;p&gt;else&lt;/p&gt;
&lt;p&gt;r := 'D';&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;CaseTest := r;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;{While...do语句}&lt;/p&gt;
&lt;p&gt;procedure WhileTest(n : Integer);&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;while n &amp;gt; 0 do&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;{writeln(I：n)-单域宽输出格式}&lt;/p&gt;
&lt;p&gt;WriteLn('*' : n);&lt;/p&gt;
&lt;p&gt;n := n - 1;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;{Repeat语句（自带语句括号功能）}&lt;/p&gt;
&lt;p&gt;procedure RepeatTest(n : Integer);&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;repeat&lt;/p&gt;
&lt;p&gt;Writeln('Im in repeater ');&lt;/p&gt;
&lt;p&gt;n := n -1;&lt;/p&gt;
&lt;p&gt;until n &amp;lt; 0;&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;{for...do语句}&lt;/p&gt;
&lt;p&gt;function ForTest(n : Integer): Integer;&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;i, sum : Integer;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;sum := 0;&lt;/p&gt;
&lt;p&gt;for i:=1 to 100 do&lt;/p&gt;
&lt;p&gt;sum := sum + i;&lt;/p&gt;
&lt;p&gt;Writeln(sum);&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;IfTest1(10);&lt;/p&gt;
&lt;p&gt;IfTest1(-5);&lt;/p&gt;
&lt;p&gt;IfTest1(0);&lt;/p&gt;
&lt;p&gt;IfTest2(3);&lt;/p&gt;
&lt;p&gt;IfTest2(-2);&lt;/p&gt;
&lt;p&gt;Writeln(CaseTest(95));&lt;/p&gt;
&lt;p&gt;Writeln(CaseTest(85));&lt;/p&gt;
&lt;p&gt;Writeln(CaseTest(75));&lt;/p&gt;
&lt;p&gt;Writeln(CaseTest(65));&lt;/p&gt;
&lt;p&gt;Writeln(CaseTest(55));&lt;/p&gt;
&lt;p&gt;WhileTest(4);&lt;/p&gt;
&lt;p&gt;WhileTest(5);&lt;/p&gt;
&lt;p&gt;WhileTest(0);&lt;/p&gt;
&lt;p&gt;RepeatTest(5);&lt;/p&gt;
&lt;p&gt;ForTest(100);&lt;/p&gt;
&lt;p&gt;Readln;&lt;/p&gt;
&lt;p&gt;end.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用数组&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;program&lt;/span&gt; &lt;span class="n"&gt;P3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;使用数组&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;APPTYPE&lt;/span&gt; &lt;span class="n"&gt;CONSOLE&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;uses&lt;/p&gt;
&lt;p&gt;SysUtils;&lt;/p&gt;
&lt;p&gt;const&lt;/p&gt;
&lt;p&gt;n = 5;&lt;/p&gt;
&lt;p&gt;type&lt;/p&gt;
&lt;p&gt;{定义类型-数组类型}&lt;/p&gt;
&lt;p&gt;No = array[1..n] of Integer;&lt;/p&gt;
&lt;p&gt;S = array[1..n] of Real;&lt;/p&gt;
&lt;p&gt;var&lt;/p&gt;
&lt;p&gt;i : Integer;&lt;/p&gt;
&lt;p&gt;k : Real;&lt;/p&gt;
&lt;p&gt;{创建数组类型变量}&lt;/p&gt;
&lt;p&gt;num : No;&lt;/p&gt;
&lt;p&gt;score : S;&lt;/p&gt;
&lt;p&gt;{直接创建一个数组变量}&lt;/p&gt;
&lt;p&gt;t : array[0..5] of Integer;&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;k := 0;&lt;/p&gt;
&lt;p&gt;for i := 1 to n do&lt;/p&gt;
&lt;p&gt;begin&lt;/p&gt;
&lt;p&gt;Readln(score[i]);&lt;/p&gt;
&lt;p&gt;k := k + score[i];&lt;/p&gt;
&lt;p&gt;end;&lt;/p&gt;
&lt;p&gt;k := k / n;&lt;/p&gt;
&lt;p&gt;Writeln('平均分为：', k);&lt;/p&gt;
&lt;p&gt;Readln;&lt;/p&gt;
&lt;p&gt;end.&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;今天基础部分到这儿，明天理一理集合、记录，再练习一些小程序，就可以由Pascal转入Delphi了~&lt;/p&gt;</summary><category term="Pascal"></category></entry></feed>