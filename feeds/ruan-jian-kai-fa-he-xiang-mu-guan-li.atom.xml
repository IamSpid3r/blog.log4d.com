<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Log4D</title><link href="/" rel="alternate"></link><link href="/feeds/ruan-jian-kai-fa-he-xiang-mu-guan-li.atom.xml" rel="self"></link><id>/</id><updated>2014-01-21T00:20:06+08:00</updated><entry><title>从 SVN 到 Git，找回丢失的历史</title><link href="/2014/01/renamed-svn-to-git/" rel="alternate"></link><updated>2014-01-21T00:20:06+08:00</updated><author><name>alswl</name></author><id>tag:,2014-01-21:2014/01/renamed-svn-to-git/</id><summary type="html">&lt;p&gt;前段时间在将公司的 SVN 项目迁移到 Git 上面去，遇到一个很少见的问题：
有一个小伙伴使用 git-svn 做 &lt;code&gt;rename&lt;/code&gt; 操作时候，将一个目录 &lt;code&gt;svn mv&lt;/code&gt; 了，
导致新目录只存了最近几个月提交历史，丢失了历史信息。对团队开发而言，
历史提交是非常宝贵的财产，我们想了一些办法，把这些数据提取出来。&lt;/p&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;# 找出丢失之前的版本，列出丢失目录上层的操作记录。&lt;/span&gt;
&lt;span class="n"&gt;svn&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="mi"&gt;2000&lt;/span&gt; &lt;span class="n"&gt;svn&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//log4d.com/trunk/apps/ios/ | less&lt;/span&gt;

&lt;span class="cp"&gt;# 将重命名之前的版本拷贝到一个临时目录&lt;/span&gt;
&lt;span class="n"&gt;svn&lt;/span&gt; &lt;span class="n"&gt;copy&lt;/span&gt; &lt;span class="n"&gt;svn&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//log4d.com/trunk/apps/ios/nami@43252 svn://log4d.com/trunk/apps/ios/nami_lost&lt;/span&gt;

&lt;span class="cp"&gt;# 准备现有代码到 Git&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;svn&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;svn&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//log4d.com/ -T trunk/apps/ios/nami -t tags -b branches -r 13532 nami&lt;/span&gt;

&lt;span class="cp"&gt;# 修改 .git/config 来加入丢失的历史数据 Remote&lt;/span&gt;
&lt;span class="err"&gt;比如&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;svn&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;svn-lost&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;svn&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//log4d.com&lt;/span&gt;
    &lt;span class="n"&gt;fetch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;trunk&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;apps&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ios&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;nami_lost&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;refs&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;remotes&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;trunk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;lost&lt;/span&gt;

&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;svn&lt;/span&gt; &lt;span class="n"&gt;fetch&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;并获取&lt;/span&gt; &lt;span class="n"&gt;Remote&lt;/span&gt; &lt;span class="err"&gt;内容&lt;/span&gt;

&lt;span class="cp"&gt;# Rebase 新代码到恢复过来的历史记录上&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;checkout&lt;/span&gt; &lt;span class="n"&gt;master&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;rebase&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;committer&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;is&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;author&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt; &lt;span class="n"&gt;trunk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;lost&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中注意的是手动添加一个 &lt;code&gt;svn-remote&lt;/code&gt; 地址为历史数据副本地址。
还有就是 &lt;code&gt;rebase&lt;/code&gt; 时候参数 &lt;code&gt;--committer-date-is-author-date&lt;/code&gt;
可以保证 &lt;code&gt;rebase&lt;/code&gt; 不会造成提交时间被修改，方便回溯。&lt;/p&gt;
&lt;p&gt;整整搞了一天，说出来都是泪，希望看到的人用不到，搜到的人用得到。&lt;/p&gt;</summary><category term="SVN"></category><category term="Git"></category></entry><entry><title>读《人件》</title><link href="/2013/04/peopleware/" rel="alternate"></link><updated>2013-04-10T23:35:00+08:00</updated><author><name>alswl</name></author><id>tag:,2013-04-10:2013/04/peopleware/</id><summary type="html">&lt;p&gt;事情起源于动态语言和静态语言之争，最后争论焦点转移到：「相信人本身的能力重要，
还是通过语言/工具来约束人重要」。
我认为项目开发中最重要的是个人能力和团队协作能力，工具只是加分项。
如果代码质量差、监控难、性能难以优化，解决根本问题的关键还是在人身上。
并不是静态编译和工具检查就能搞定了。&lt;/p&gt;
&lt;p&gt;我愤愤的在 QQ 对话框中写道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我工作第一年痛苦于开发流程，阅读了《人月神话》，就开始坚信软件工程的哲学
后来痛苦与代码质量，阅读了《重构》，开始坚信代码质量决定产品质量
现在痛苦于人和语言的冲突，动态和静态的冲突，我想读《人件》了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="人件" src="http://img3.douban.com/lpic/s1299961.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;人件已经绝版，只能在找线上版，我花了两个星期把它读完。
书中给了我一部分答案，另外还有一些意外的收获。&lt;/p&gt;


&lt;p&gt;《人件》其实讲了一件事情：怎样将脑力劳动者管理好，打造出一个高效的团队。&lt;/p&gt;
&lt;p&gt;《人件》@豆瓣： &lt;a href="http://book.douban.com/subject/1108725/"&gt;http://book.douban.com/subject/1108725/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;《人件》在线阅读地址： &lt;a href="http://book.zi5.me/books/read/2206"&gt;http://book.zi5.me/books/read/2206&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;吐槽：翻译太烂太烂太烂了，下次要看直接去看翻译版。&lt;/p&gt;
&lt;h2&gt;以人为本&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;我们工作的主要挑战，与其说来源于技术，不如说来源于团队成员本身&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;技术人员转成项目经理经理之后，往往继续用工程化思维管理人员，
认为人是可以设计成标准化接口，是可以替换的。很可惜，这种想法不是那么 &lt;strong&gt;有效&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因为脑力劳动和体力重复劳动不一样，不是在卖汉堡这种重复工作，
而是需要创造、思考和发明的工作。软件经理需要提供有限额的错误机会。
错误无法完全避免，并且是工作内容的健康组成部分。一旦硬性阻止犯错，
会让团队成员失去创造的勇气。
我相信这也是为什么 Facebook 早期会践行「Break it Down」。&lt;/p&gt;
&lt;h2&gt;何不双赢&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;西班牙人的理论坚持认为地球上只有一个固定数量的价值，
因此通向积累财富的道路就是学会从土地或者从人身上更有效地榨取财富。
而英国人的理论认为价值可以通过天才和技术创造出来。因此英国就产生了工业革命，
而西班牙人就转动起了车轮，开始开拓疆土和剥削在新大陆的印第安人。
他们从海上运回大量的黄金，
他们所有努力带来的却是通货膨胀（太多的金钱追逐太少的有用货物）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我坚信公司和员工并不是对立面的，双赢才是正确的路线。
大部分情况下，我愿意牺牲个人时间和精力来完成公司的任务。
前提就是对产品有认同感，对公司有归属感。&lt;/p&gt;
&lt;h2&gt;最好和最坏&lt;/h2&gt;
&lt;p&gt;作者通过一个持续两年，有来自 92 个公司的 600 多名开发程序员参加的比赛，
分析出以下数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;成绩最好与成绩最差的人之间的绩效比率是10 : 1。&lt;/li&gt;
&lt;li&gt;最好选手成绩大约是中等成绩选手成绩的2.5倍。&lt;/li&gt;
&lt;li&gt;成绩中等以上的一半选手与另外一半选手的绩效比是2 : 1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="http://www.aqee.net/"&gt;外刊 IT 评论&lt;/a&gt;的
&lt;a href="http://www.aqee.net/why-programmers-are-not-paid-in-proportion-to-their-productivity/"&gt;为什么程序员的工作效率跟他们的工资不成比例&lt;/a&gt; 一文中也提供一些数据支持。&lt;/p&gt;
&lt;p&gt;我离最好还有很长的距离，但是我相信个人能力是可以提升的，
并且在个人能力上面的投资汇报比极高。&lt;/p&gt;
&lt;h2&gt;高效工作的秘诀&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;进入顺流：咦？怎么时间过得这么快？！&lt;/li&gt;
&lt;li&gt;邮件比电话更不容易打乱人的思绪&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;团队的力量&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;团结起来，工作的更高效更开心&lt;/li&gt;
&lt;li&gt;有目标的团队，1 + 1 &amp;gt; 2&lt;/li&gt;
&lt;li&gt;为一个共同的目标走到一起&lt;/li&gt;
&lt;li&gt;优秀的团队里的成员，不会因为钱、阶层、晋升的问题离开团队&lt;/li&gt;
&lt;li&gt;优秀的团队往往是带有个性的&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;《人人都是产品经理》中当时讲了一个愿景（Vison）问题，
我相信一个好的愿景可以吸引更多高质量人才，为赚钱而创建的团队是不会长久的。&lt;/p&gt;
&lt;h2&gt;烂团队的苗头&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;防范团队成员&lt;/li&gt;
&lt;li&gt;官僚作风&lt;/li&gt;
&lt;li&gt;不挨在一起工作（空间上）&lt;/li&gt;
&lt;li&gt;某个成员的职责被分割多份&lt;/li&gt;
&lt;li&gt;对产品质量要求降低&lt;/li&gt;
&lt;li&gt;无意义的截止日期（不可能达到的目标）&lt;/li&gt;
&lt;li&gt;结党营私&lt;/li&gt;
&lt;li&gt;加班&lt;/li&gt;
&lt;li&gt;绩效考核 / 目标奖励 &lt;/li&gt;
&lt;li&gt;早期时候人员超编&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里和上文的愿景问题是对应的，无论是强制加班还是通过考核回报激励，
都不是激发人的创造力和战斗力的好方法。老大们应该学会画饼，画大饼。
另外，管理团队果然好难：做的事情必须靠谱，才能吸引到人才；
需要能管理好有个性的人才（比如伞哥这样的）； 在中国大环境下，还要不错的物质回报。&lt;/p&gt;
&lt;h2&gt;经营好团队&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;崇拜高质量：因为市场和用户需要高质量的产品&lt;/li&gt;
&lt;li&gt;通过里程碑的方式管理任务，提高士气&lt;/li&gt;
&lt;li&gt;崇拜精英&lt;/li&gt;
&lt;li&gt;允许和鼓励异端：异端代表创新和进化，没有异端就会种群灭亡&lt;/li&gt;
&lt;li&gt;给予自由度：对成员信任，而不是纯粹服从权威工作&lt;/li&gt;
&lt;li&gt;交流，唤醒那些有潜力的巨人（唤醒了才能将脑力劳动能力发挥到极限）&lt;/li&gt;
&lt;li&gt;内部竞争和培养&lt;/li&gt;
&lt;li&gt;管理层自身的学习，公司自身定位的不断改变&lt;/li&gt;
&lt;li&gt;将公司内部建设出社区文化（我觉得就是公司团队文化建设嘛）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;我有一个观点是工程质量决定产品质量，产品质量决定整个团队。
质量的一个标准是：&lt;strong&gt;我以此为荣&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;工作是一种乐趣&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;将混乱重建成秩序是有趣的&lt;/li&gt;
&lt;li&gt;敢于用小项目来做尝试&lt;/li&gt;
&lt;li&gt;组织竞赛游戏&lt;/li&gt;
&lt;li&gt;团队头脑风暴&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;这本这么老的书居然提到团队竞争游戏，和 Facebook 的 Hackday 异曲同工啊。
再为这种乐趣补充一点：将公司的成果分享到开源社区。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;团队成员需要做到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;界定自己工作，成为主人翁&lt;/li&gt;
&lt;li&gt;促使自己成长为多面手，而不是单纯某个职位&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;给了成员足够的自由度，那么就会有相应的风险，需要对他们进行监测，
另外招人时候就需要找靠谱的人，这也是为什么 Facebook / Google / 早期百度对招人要求极其严格。&lt;/p&gt;
&lt;h2&gt;流程改进&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;CMM 是标准，是标准的话就一定不是对于个体的最优情况&lt;/li&gt;
&lt;li&gt;CMM 自身也在改进，说明上一个版本的 CMM 不是最优&lt;/li&gt;
&lt;li&gt;流程的目标是：提高质量 / 提高生产力 / 减少风险&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;读后感&lt;/h2&gt;
&lt;p&gt;发挥个人的能力才是最关键的，要点在于信任、自由、乐趣。原则是 Pull 而不是 Push。&lt;/p&gt;
&lt;p&gt;我会继续学习和思考这些原则，因为总有一天我也会面临这样的挑战。&lt;/p&gt;</summary><category term="创业"></category><category term="读书笔记"></category></entry><entry><title>软件开发中的角色扮演</title><link href="/2010/01/software-development-in-the-role-playing/" rel="alternate"></link><updated>2010-01-09T00:00:00+08:00</updated><author><name>alswl</name></author><id>tag:,2010-01-09:2010/01/software-development-in-the-role-playing/</id><summary type="html">&lt;p&gt;说到软件开发的过程、环节等等，我印象里只剩下一大堆术语和一些流程的大概，但是因为缺乏正规开发的经验，所以并没有对软件开发中每个人的角色有深入理解，今天在周末
检查Delicious Temp标签时候，看到 &lt;a href="http://blog.boluotou.com/"&gt;圆木菠萝头&lt;/a&gt;
的这片文章，收获颇丰，现在转载与大家分享。&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href="http://blog.boluotou.com/Developer/2009/06/S
oftware_Role"&gt; 软件开发中的角色扮演 - 软件开发 - 圆木菠萝罐&lt;/a&gt;&amp;amp;nbsp_place_holder; （我稍微调了一下格式，没有修改文章内容 ^_^）&lt;/p&gt;
&lt;p&gt;××××××XXX分哥线XXX×××××××&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;商业软件开发并不是只有一个编程的人，而是可以分为不同的角色。&lt;/p&gt;
&lt;p&gt;不同的软件公司因为规模大小性质各不相同，所以围绕软件的角色也各不相同。这就好比在重点学校里面分级很明确，每科有个老师，每个年级每个班级都有各自的老师，也有主
任书记校长支持角色。而在电影《一个都不能少》级别的学校里面，往往一个老师兼职从语文教到体育，年级从一年级到六年级。类似的说，一个大型的软件外包企业，外资企业
，往往分工明确细致，每个人像螺丝钉一样在一起工作，让整个大机器得以运转。而在一个小型创业企业里面，往往一个人从接触客户，到开发产品到交付产品＊＊＊走完，整个
产品周期就一个人，甚至几个产品周期就一个人。&lt;/p&gt;
&lt;p&gt;所以解释角色要针对性。远的不说，就拿我们的项目组来举例。我们项目组可以说一共有5种角色，开发（DEV），测试（QA），质量监督（SQA），技术主管
（Tech-Lead）,开发经理（SDM）。&lt;/p&gt;
&lt;h2&gt;1. 开发 （DEV）&lt;/h2&gt;
&lt;p&gt;编程能力 ★★★★★&lt;/p&gt;
&lt;p&gt;业务认知 ★★☆&lt;/p&gt;
&lt;p&gt;沟通能力 ★★☆&lt;/p&gt;
&lt;p&gt;管理能力 N/A&lt;/p&gt;
&lt;p&gt;全局观 N/A&lt;/p&gt;
&lt;p&gt;开发就是大家经常说的编程的人。工作主要是写代码，其次是跟团队成员客户沟通。前后者比例大概是7：3的关系。开发是整个软件开发团队当中的最重要的角色之一，道理很
简单，产品出自于他们的亲手。说到开发，大家的印象就是整天呆在电脑面前，目光呆滞，头发凌乱的计算机人士。确实，整天和计算机打交道的人的确容易变成这样，因为开发
首要解决的问题就是如何用技术能力去解决客户的需求，而不是自己的形象怎么样。事实上这种情况在现代中得到很大改善，很多IT人士都很注重自身形象。&lt;/p&gt;
&lt;p&gt;具体的工作不仅要写代码用算法实现业务逻辑，更要有程序设计的思想，大到整个的程序框架，小到某个小模块的扩展性兼容性，都是在开发真正写代码之前着重要考虑的方面。&lt;/p&gt;
&lt;p&gt;现在的编程不像以前打孔式编程那么艰涩，大厂商开发的强大的编程工具（IDE）让编程事半功倍。然而技术在变简单的同时，客户需求又在日趋复杂化。而技术就是为了实现
业务逻辑，将业务逻辑抽象建模用计算机程序的方式表现出来，所以一个不懂业务逻辑的开发不会了解模块和模块之间如何协同工作，这便给工作带来很大的局限性。而如果一个
开发只关注每个模块之内的细节实现，那在现实中便不是一个好开发，至少不是一个好用的开发。&lt;/p&gt;
&lt;p&gt;沟通方面，开发需要和测试，技术主管，开发经理，甚至客户方面沟通，所以必要的沟通能力还是很需要的。现在的软件不再是一个人在战斗，在团队作战中，开发有时需要和测
试讨论"某个软件Bug（缺陷）是不是Bug"，有时需要和技术主管讨论客户的某个需求到底是要实现什么内容，有时需要和开发经理讨论项目的进度是否需要推迟。&lt;/p&gt;
&lt;p&gt;就开发的工作本身而言，是不太需要管理能力和全局观的，如果能够做好编程的工作之外，这两方面也比较强，可能就离升职加薪不远了。&lt;/p&gt;
&lt;h2&gt;2. 测试（QA）&lt;/h2&gt;
&lt;p&gt;编程能力 ★★☆&lt;/p&gt;
&lt;p&gt;业务认知 ★★★★&lt;/p&gt;
&lt;p&gt;沟通能力 ★★★&lt;/p&gt;
&lt;p&gt;管理能力 N/A&lt;/p&gt;
&lt;p&gt;全局观 ★☆&lt;/p&gt;
&lt;p&gt;任何一个产品都需要测试，就好比制造业中如果生产了一批电灯，我们不能听制灯师傅说信得过而信得过，而得通过一系列模拟用户的行为来对电灯进行测试，指标合格后方可出
厂投入市场。&lt;/p&gt;
&lt;p&gt;软件测试也一样，需要对开发者开发出来的模块，产品进行全方位的测试。&lt;/p&gt;
&lt;p&gt;原则是"做正确的事"，让客户需求功能得到满足。&lt;/p&gt;
&lt;p&gt;基本做事方法就是模拟客户的一切日常行为，包括一些极其变态的行为，考验软件在各个方面的情况下的可用性和稳定性。而这些"日常行为"便称之为测试用例（Test
case），一个好的QA会设计出一套可以覆盖所有检查点（check point），又不重叠的测试用例，这套功底可以参考MECE方法。既然如此，QA就需要对整
个软件的业务相当熟悉，因为她（他）要知道在某个用户行为下，软件是否做出了正确的反应。&lt;/p&gt;
&lt;p&gt;既然是模拟用户行为，那么QA就需要去手动"跑"测试用例。当一个系统很大的时候，测试用例极其多，光用手点一遍是非常耗费时间和人力的，所以QA可以做自动化测试。
所谓自动化，便是QA编写一些脚本代码，让计算机帮助去实现一些人为的行为，而不用自己手动点。所以这就需要QA做有一些代码编写能力。&lt;/p&gt;
&lt;p&gt;测试方面有个重要的概念是黑盒测试和白盒测试。简单的说，黑盒测试就是在软件界面上用手点，不管后面的代码写得怎么样，只要我点击某个按钮或者其他元件的时候，结果是
我想要的就OK。所以叫"黑盒"，意思是看不到"里面的代码"。而白盒测试就是要直接审阅（review）代码，通过看代码发现业务逻辑，代码效率，后台数据操作等等
，可以说比黑盒测试要细致得多，当然成本可能也更多。所以叫"白盒"，意思是透明的盒子，可以看到里面的代码。所以，白盒测试是需要QA有一定的编程能力的。&lt;/p&gt;
&lt;p&gt;沟通方面，QA经常要和DEV讨论Bug（软件缺陷），Bug的意思是本应该有的功能却没有做到的功能。对于某些比较似是而非的Bug, 怎么能够让开发者心服口服地
承认并去修复往往需要花费一番口舌。而这些Bug往往是根据不同的人的价值观认定是不是Bug，所以合理地传递价值观也是QA的一个基本素质。现实的一个案例是，公司
某QA"传递价值观"能力极强，于是被拉去做市场去了。除此之外，QA还要经常和技术主管沟通，熟悉客户需求。&lt;/p&gt;
&lt;p&gt;全局观是因为QA要做集成测试，这样需要对产品本身有个全局的观念。比如产品有个用户管理系统和订单管理系统，那么对于"删除一个用户"的行为，用户的订单会怎么处理
？这便是一个全局观的意识。往往一个好的QA在这点上可以帮用户想到很多用户没想到的东西。&lt;/p&gt;
&lt;h2&gt;3. 质量监督（SQA）&lt;/h2&gt;
&lt;p&gt;编程能力 N/A&lt;/p&gt;
&lt;p&gt;业务认知 ★&lt;/p&gt;
&lt;p&gt;沟通能力 ★★★☆&lt;/p&gt;
&lt;p&gt;管理能力 ★★★&lt;/p&gt;
&lt;p&gt;全局观 ★★☆&lt;/p&gt;
&lt;p&gt;如果说QA的作用是确保"做正确的事"，那么SQA的作用就是确保"正确的做事"。&lt;/p&gt;
&lt;p&gt;通常SQA是不会直接参与软件开发的工作中，而是通过在一旁监督软件开发的过程，然后把监测的结果反馈给软件开发团队。&lt;/p&gt;
&lt;p&gt;既然是监督过程，所以SQA经常是流程化的代名词。流程是外企当中比较看重的东西，从每天的Daily report, 到每周的weekly meeting，从什
么时候把当天的结果存到服务器上，到为什么团队出现重大事故，几乎都会有SQA的参与。所以在前期制定一个符合项目的流程是SQA的必然工作。项目运行过程中，所有项
目流程规定的点所涉及到的邮件都要CC一份给SQA。&lt;/p&gt;
&lt;p&gt;当SQA通过流程观察项目的运行情况的时候，必然会收集到很多数据（包括刚才提到的邮件）。SQA会对这些数据进行统计归纳，然后总结出规律和报告直接递交给总监（D
irector）。鉴于此，SQA在我们公司地位还是很高的。&lt;/p&gt;
&lt;p&gt;SQA还会不定期对开发团队进行个人的face to
face面对面一对一沟通，名字叫Audit，中文翻译过来类似叫审计。这种行为更针对"人"的评估，而不再是产品。因为产品的好坏决定于人的好坏。&lt;/p&gt;
&lt;h2&gt;4. 技术主管（Tech-Lead）&lt;/h2&gt;
&lt;p&gt;编程能力 ★★★★☆&lt;/p&gt;
&lt;p&gt;业务认知 ★★★★★&lt;/p&gt;
&lt;p&gt;沟通能力 ★★★★☆&lt;/p&gt;
&lt;p&gt;管理能力 ★★★★&lt;/p&gt;
&lt;p&gt;全局观 ★★★★&lt;/p&gt;
&lt;p&gt;技术主管在我们公司往往就是一个项目的负责人。最主要的工作莫过于软件架构设计，客户需求沟通，技术难点解决和内部团队管理。&lt;/p&gt;
&lt;p&gt;技术主管，名字便告诉了大家技术功底一定要很牛，在我们公司经常是一些工作了2-3年以上的软件工程师或者高级软件工程师担当。虽然技术很牛，不过实际上直接参与软件
开发的还是DEV（开发者），技术主管只是在比较高的一层面进行协调，所以直接代码编程很少。但是遇到了技术障碍DEV无法克服的时候，技术主管一定要及时站出来做一
个Problem solver。&lt;/p&gt;
&lt;p&gt;技术主管的日常主要工作就是和客户沟通，熟悉需求，然后把业务需求转换成软件需求给DEV去做。所以技术主管对业务逻辑要相当的熟悉，在整个项目角色中，对业务最熟悉
的除了客户就是技术主管。所以技术主管起到了一个衔接的作用，沟通起了客户和开发，连接起了现实的业务需求和虚拟的软件实现。这一切，对技术主管的沟通能力的要求就很
高了。&lt;/p&gt;
&lt;p&gt;软件团队不是一直和谐的，有时会出现某个模块的接口和另外一个模块的接口衔接不上，有时会出现一个人的工作被另外一个人的工作Block（中断）了，有时也会出现某个
DEV总是不买某个QA的账等等，所有的这一切，从技术到人本身，都在时时考验一个技术主管的管理水平。&lt;/p&gt;
&lt;h2&gt;5. 开发经理（SDM）&lt;/h2&gt;
&lt;p&gt;编程能力 ★★★☆&lt;/p&gt;
&lt;p&gt;业务认知 ★★★★☆&lt;/p&gt;
&lt;p&gt;沟通能力 ★★★★★&lt;/p&gt;
&lt;p&gt;管理能力 ★★★★★&lt;/p&gt;
&lt;p&gt;全局观 ★★★★★&lt;/p&gt;
&lt;p&gt;软件开发经理是一般软件项目中执行层面上的最高职位了。其主要作用是项目的进度控制，客户高层沟通，甚至到项目预算控制。&lt;/p&gt;
&lt;p&gt;软件开发经理的编程功底要看具体人而定，在我们公司软件开发经理一般都是技术出身，5-8年的工作经验或软件行业的资历。在具体的项目中，几乎不参与任何代码的编写和
设计工作。前期的项目计划（Project Plan），中期的项目进度管理和客户需求管理，到后期的项目交付，所有的工作都是软件开发经理和客户主要要沟通的东西。&lt;/p&gt;
&lt;p&gt;业务方面，软件开发经理对业务认知的能力是非常强悍的，因为资历深的人对很多陌生的业务嗅觉和认知要比其他人强。不过在实际中，业务需求方面大部分工作给技术主管做了
，所以软件开发经理主要关注于项目总体，对细节不太关注了。&lt;/p&gt;
&lt;p&gt;软件开发经理还有个重要的作用便是在软件项目过程中，积极地调动项目内外的资源。简单的说，把合适的人放在合适的位置上。当团队出现无法解决的问题时，软件开发经理会
想方设法从外部获取资源帮助团队渡过难关。&lt;/p&gt;
&lt;p&gt;总的说了这么多，只是为了从宏观层面解释下这些角色的作用，目的是让新手大概的了解下这些角色的作用，以便今后在工作中将自己放在合适的角色以及和其他角色合作中心里
有个准备。&lt;/p&gt;
&lt;p&gt;&amp;amp;nbsp_place_holder;&lt;/p&gt;</summary><category term=""></category></entry><entry><title>用户权限设计的问题</title><link href="/2009/06/design-of-user-rights/" rel="alternate"></link><updated>2009-06-25T00:00:00+08:00</updated><author><name>alswl</name></author><id>tag:,2009-06-25:2009/06/design-of-user-rights/</id><summary type="html">&lt;h3&gt;问题&lt;/h3&gt;
&lt;p&gt;用户权限设计这一块，一直是一个我觉得比较难解决的问题。&lt;/p&gt;
&lt;p&gt;以前我用了「伪继承」，虽然管理员继承了普通用户，但是数据库却是分开设计的。又或者压根没有继承关系，是两个不同的实体。&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;p&gt;这次在贴吧系统，有三个用户角色：普通用户、吧主、管理员，想设计的符合OO，但又要利于数据库的实现。就有几个问题需要解决：1.需要继承么；2.数据库怎么设计；
3.Hibernate怎么映射。最后参考几篇文章，设计成如下。&lt;/p&gt;
&lt;p&gt;使用User类，Roll类，User具有一般用户属性，Roll负责角色，他们是1对1关系，最好在数据库有一张User-
Roll的对应关系表。来标明这个User具有哪个Roll。&lt;/p&gt;
&lt;p&gt;在我这个系统，Roll类有三种，分别对应三种角色：普通用户，吧主和管理员。&lt;/p&gt;
&lt;p&gt;这种独立出Roll角色类的方法被称为基于角色的用户权限设计方法。&lt;/p&gt;
&lt;p&gt;[caption id="attachment_12439" align="alignnone" width="300" caption="User
Roll UML类图"]&lt;a href="http://upload-
log4d.qiniudn.com/2009/06/Snap2.jpg"&gt;&lt;img alt="User Roll UML类图" src="http://upload-" title="log4d.qiniudn.com/2009/06/Snap2-300x148.jpg" /&gt;&lt;/a&gt;[/caption]&lt;/p&gt;
&lt;p&gt;我给出的这个其实还不完善，完整的解决方案应该还包含ACL列表，可以定制Roll对应ACL列表的对应，来修改某一个角色的权限。因为我的系统角色固定，而且系统规
模比较小，我所说的三种发难已经能够满足我的要求了。&lt;/p&gt;
&lt;h3&gt;参考资料&lt;/h3&gt;
&lt;p&gt;用户权限设计&amp;lt;&lt;a href="http://blog.chinaunix.net/u1/42750/showart_359641.html"&gt;猛击这里打开&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;基于角色的用户权限设计问题&amp;lt;&lt;a href="http://blog.csdn.net/seapen/archive/2006/03/15/624734.a
spx"&gt;猛击这里打开&lt;/a&gt;&amp;gt;&lt;/p&gt;</summary><category term=""></category></entry><entry><title>用户界面设计黄金原则</title><link href="/2009/06/gold-user-interface-design-principles/" rel="alternate"></link><updated>2009-06-02T00:00:00+08:00</updated><author><name>alswl</name></author><id>tag:,2009-06-02:2009/06/gold-user-interface-design-principles/</id><summary type="html">&lt;p&gt;在《用户界面设计要素》一书（1997）中，T.Mandel提出了3条「黄金」知道规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;让用户驾驭软件，而不是软件驾驭用户。那种在给用户的操作加上许多约束和限制的界面虽然设计容易，却往往难学难用。&lt;/li&gt;
&lt;li&gt;尽可能减少用户的记忆。为此可建立易记的快捷键（例如Ctrl+p启动「打印」）；采用演进形式显示「提示」信息，以免要用户一次记忆大量信息。&lt;/li&gt;
&lt;li&gt;保持界面的一致性。例如在同类产品中使用相同的设计规则；尽可能不改变用户已熟悉的操作功能键（例如用Ctrl+S保存文件）；设定界面的缺省状态。
最近停下了贴吧的下一步开发，恶补软件工程，为下一步开发做理论基础。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一边啃Rober C.大人写的《敏捷软件开发》。白天都浪迹在考研自习室（很是安静啊），更新变慢，勿怪。&lt;/p&gt;</summary><category term=""></category></entry><entry><title>软件自然理论</title><link href="/2009/05/natural-theory-of-software/" rel="alternate"></link><updated>2009-05-31T00:00:00+08:00</updated><author><name>alswl</name></author><id>tag:,2009-05-31:2009/05/natural-theory-of-software/</id><summary type="html">&lt;p&gt;所谓软件自然理论，就是说：一个优秀的软件，他的功能模块设计，应该与用户在完全没有接触过这个系统时候所想要的功能设计一致，用户觉得他想要的功能在什么地方，应该
怎样实现，那么这个功能就是应该在那里，就是应该这样实现。&lt;/p&gt;
&lt;p&gt;这么说感觉上会很绕口，那么举个例子。Office就是一个比较优秀的软件，如果一个用户完全没有接触过Office（当然，必须具备基本的电脑使用水平），如果该用
户想对字体进行设置，那么他就觉得字体设置属于格式，就应该在格式菜单里面，用户去点击这个菜单，就找到了自己需要的功能。&lt;/p&gt;
&lt;p&gt;其他的，比如WinRAR，IE浏览器，都是出色的软件，他们的模块设计也都是符合用户的想法的。&lt;/p&gt;
&lt;p&gt;如果一个软件功能过于复杂，或者说功能的安排有很多方案，那么用户往往会难于在短时间内找到自己想要的功能，就会产生对该软件的「惰性」，也就是不想用这个软件了。比
如说AutoCAD,3DMax，如果想熟练使用，往往要经过一段时间的学习的。&lt;/p&gt;
&lt;p&gt;ps:这个理论你肯定找不到的，Google也不会有，因为....这是我編出来忽悠继烨、道哥的....很不幸，他们纷纷上当....&lt;/p&gt;</summary><category term=""></category></entry><entry><title>我在看设计模式</title><link href="/2009/01/i-look-at-design-patterns/" rel="alternate"></link><updated>2009-01-18T00:00:00+08:00</updated><author><name>alswl</name></author><id>tag:,2009-01-18:2009/01/i-look-at-design-patterns/</id><summary type="html">&lt;p&gt;花了6天时间把创建型5种模式看完了，很有感触，但是感触不意味着我理解，我甚至私下里觉得OOD的设计模式不适合我现在做的那些程序，那些都是一次成型，根本谈不上
需求的改变。没有改变，就不需要OO思想。因为我这样的想法，我看起来很累。
我知道这些思想对我以后的发展很有帮助，会从思想上把我解救出来，我被这些新的设计想法激动着（虽然出来很多年，可是对于我来说完全是新的，呵呵```）。&lt;/p&gt;
&lt;p&gt;嗯，坚持下去&lt;/p&gt;
&lt;p&gt;这几天我也在想以后走IT哪一条路。想了好久，现在的想法是：计算机本质上是一种工具，软件的存在是为了计算机更好的服务。既然是一个工具，就要有工具的觉悟，就必须
不断适应生产力的发展，需要完善自身功能，也就是需求的变化。正是因为需求的变化，使得敏捷软件开发成为现在的主流。&lt;/p&gt;
&lt;p&gt;呃&lt;code&gt;我才看了几天设计模式，就说的这么狂&lt;/code&gt;激动了，激动了```&lt;/p&gt;</summary><category term="设计模式"></category></entry></feed>